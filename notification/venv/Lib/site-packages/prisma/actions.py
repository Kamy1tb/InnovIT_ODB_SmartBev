# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases

if TYPE_CHECKING:
    from .client import Client
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class annonceurActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.annonceur]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await annonceur.prisma().query_raw(
            'SELECT * FROM annonceur WHERE id = ?',
            1103527590,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.annonceur
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await annonceur.prisma().query_first(
            'SELECT * FROM annonceur WHERE nom = ?',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.annonceurCreateInput,
        include: Optional[types.annonceurInclude] = None
    ) -> _PrismaModelT:
        """Create a new annonceur record.

        Parameters
        ----------
        data
            annonceur record data
        include
            Specifies which relations should be loaded on the returned annonceur model

        Returns
        -------
        prisma.models.annonceur
            The created annonceur record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a annonceur record from just the required fields
        annonceur = await annonceur.prisma().create(
            data={
                # data to create a annonceur record
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.annonceurCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple annonceur records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of annonceur record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await annonceur.prisma().create_many(
            data=[
                {
                    # data to create a annonceur record
                },
                {
                    # data to create a annonceur record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.annonceurWhereUniqueInput,
        include: Optional[types.annonceurInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single annonceur record.

        Parameters
        ----------
        where
            annonceur filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned annonceur model

        Returns
        -------
        prisma.models.annonceur
            The deleted annonceur record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        annonceur = await annonceur.prisma().delete(
            where={
                'id': 662824084,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.annonceurWhereUniqueInput,
        include: Optional[types.annonceurInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique annonceur record.

        Parameters
        ----------
        where
            annonceur filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned annonceur model

        Returns
        -------
        prisma.models.annonceur
            The found annonceur record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        annonceur = await annonceur.prisma().find_unique(
            where={
                'id': 1147902781,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.annonceurWhereInput] = None,
        cursor: Optional[types.annonceurWhereUniqueInput] = None,
        include: Optional[types.annonceurInclude] = None,
        order: Optional[Union[types.annonceurOrderByInput, List[types.annonceurOrderByInput]]] = None,
        distinct: Optional[List[types.annonceurScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple annonceur records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of annonceur records returned
        skip
            Ignore the first N results
        where
            annonceur filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned annonceur model
        order
            Order the returned annonceur records by any field
        distinct
            Filter annonceur records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.annonceur]
            The list of all annonceur records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 annonceur records
        annonceurs = await annonceur.prisma().find_many(take=10)

        # find the first 5 annonceur records ordered by the prenom field
        annonceurs = await annonceur.prisma().find_many(
            take=5,
            order={
                'prenom': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.annonceurWhereInput] = None,
        cursor: Optional[types.annonceurWhereUniqueInput] = None,
        include: Optional[types.annonceurInclude] = None,
        order: Optional[Union[types.annonceurOrderByInput, List[types.annonceurOrderByInput]]] = None,
        distinct: Optional[List[types.annonceurScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single annonceur record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            annonceur filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned annonceur model
        order
            Order the returned annonceur records by any field
        distinct
            Filter annonceur records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.annonceur
            The first annonceur record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second annonceur record ordered by the mail field
        annonceur = await annonceur.prisma().find_first(
            skip=1,
            order={
                'mail': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.annonceurUpdateInput,
        where: types.annonceurWhereUniqueInput,
        include: Optional[types.annonceurInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single annonceur record.

        Parameters
        ----------
        data
            annonceur record data specifying what to update
        where
            annonceur filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned annonceur model

        Returns
        -------
        prisma.models.annonceur
            The updated annonceur record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        annonceur = await annonceur.prisma().update(
            where={
                'id': 2035015474,
            },
            data={
                # data to update the annonceur record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.annonceurWhereUniqueInput,
        data: types.annonceurUpsertInput,
        include: Optional[types.annonceurInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            annonceur filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned annonceur model

        Returns
        -------
        prisma.models.annonceur
            The created or updated annonceur record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        annonceur = await annonceur.prisma().upsert(
            where={
                'id': 368800899,
            },
            data={
                'create': {
                    'id': 368800899,
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.annonceurUpdateManyMutationInput,
        where: types.annonceurWhereInput,
    ) -> int:
        """Update multiple annonceur records

        Parameters
        ----------
        data
            annonceur data to update the selected annonceur records to
        where
            Filter to select the annonceur records to update

        Returns
        -------
        int
            The total number of annonceur records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all annonceur records
        total = await annonceur.prisma().update_many(
            data={
                'tel': 'bfaiacjjfc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.annonceurWhereInput] = None,
        cursor: Optional[types.annonceurWhereUniqueInput] = None,
    ) -> int:
        """Count the number of annonceur records present in the database

        Parameters
        ----------
        select
            Select the annonceur fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            annonceur filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.annonceurCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await annonceur.prisma().count()

        # results: prisma.types.annonceurCountAggregateOutput
        results = await annonceur.prisma().count(
            select={
                '_all': True,
                'idCreatedpar': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.annonceurCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.annonceurWhereInput] = None,
        cursor: Optional[types.annonceurWhereUniqueInput] = None,
    ) -> types.annonceurCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.annonceurCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.annonceurWhereInput] = None,
        cursor: Optional[types.annonceurWhereUniqueInput] = None,
    ) -> Union[int, types.annonceurCountAggregateOutput]:
        """Count the number of annonceur records present in the database

        Parameters
        ----------
        select
            Select the annonceur fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            annonceur filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.annonceurCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await annonceur.prisma().count()

        # results: prisma.types.annonceurCountAggregateOutput
        results = await annonceur.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.annonceurCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.annonceurWhereInput] = None
    ) -> int:
        """Delete multiple annonceur records.

        Parameters
        ----------
        where
            Optional annonceur filter to find the records to be deleted

        Returns
        -------
        int
            The total number of annonceur records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all annonceur records
        total = await annonceur.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.annonceurScalarFieldKeys'],
        *,
        where: Optional['types.annonceurWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.annonceurAvgAggregateInput'] = None,
        sum: Optional['types.annonceurSumAggregateInput'] = None,
        min: Optional['types.annonceurMinAggregateInput'] = None,
        max: Optional['types.annonceurMaxAggregateInput'] = None,
        having: Optional['types.annonceurScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.annonceurCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.annonceurScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.annonceurScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.annonceurGroupByOutput']:
        """Group annonceur records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar annonceur fields to group records by
        where
            annonceur filter to select records
        take
            Limit the maximum number of annonceur records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.annonceurGroupByOutput]
            A list of dictionaries representing the annonceur record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group annonceur records by nom values
        # and count how many records are in each group
        results = await annonceur.prisma().group_by(
            ['nom'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class categorieActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.categorie]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await categorie.prisma().query_raw(
            'SELECT * FROM categorie WHERE id = ?',
            486256185,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.categorie
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await categorie.prisma().query_first(
            'SELECT * FROM categorie WHERE categorie = ?',
            'bagcfbhiig',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.categorieCreateInput,
        include: Optional[types.categorieInclude] = None
    ) -> _PrismaModelT:
        """Create a new categorie record.

        Parameters
        ----------
        data
            categorie record data
        include
            Specifies which relations should be loaded on the returned categorie model

        Returns
        -------
        prisma.models.categorie
            The created categorie record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a categorie record from just the required fields
        categorie = await categorie.prisma().create(
            data={
                # data to create a categorie record
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.categorieCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple categorie records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of categorie record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await categorie.prisma().create_many(
            data=[
                {
                    # data to create a categorie record
                },
                {
                    # data to create a categorie record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.categorieWhereUniqueInput,
        include: Optional[types.categorieInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single categorie record.

        Parameters
        ----------
        where
            categorie filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned categorie model

        Returns
        -------
        prisma.models.categorie
            The deleted categorie record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        categorie = await categorie.prisma().delete(
            where={
                'id': 267834847,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.categorieWhereUniqueInput,
        include: Optional[types.categorieInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique categorie record.

        Parameters
        ----------
        where
            categorie filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned categorie model

        Returns
        -------
        prisma.models.categorie
            The found categorie record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        categorie = await categorie.prisma().find_unique(
            where={
                'id': 180171308,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.categorieWhereInput] = None,
        cursor: Optional[types.categorieWhereUniqueInput] = None,
        include: Optional[types.categorieInclude] = None,
        order: Optional[Union[types.categorieOrderByInput, List[types.categorieOrderByInput]]] = None,
        distinct: Optional[List[types.categorieScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple categorie records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of categorie records returned
        skip
            Ignore the first N results
        where
            categorie filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned categorie model
        order
            Order the returned categorie records by any field
        distinct
            Filter categorie records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.categorie]
            The list of all categorie records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 categorie records
        categories = await categorie.prisma().find_many(take=10)

        # find the first 5 categorie records ordered by the id field
        categories = await categorie.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.categorieWhereInput] = None,
        cursor: Optional[types.categorieWhereUniqueInput] = None,
        include: Optional[types.categorieInclude] = None,
        order: Optional[Union[types.categorieOrderByInput, List[types.categorieOrderByInput]]] = None,
        distinct: Optional[List[types.categorieScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single categorie record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            categorie filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned categorie model
        order
            Order the returned categorie records by any field
        distinct
            Filter categorie records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.categorie
            The first categorie record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second categorie record ordered by the categorie field
        categorie = await categorie.prisma().find_first(
            skip=1,
            order={
                'categorie': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.categorieUpdateInput,
        where: types.categorieWhereUniqueInput,
        include: Optional[types.categorieInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single categorie record.

        Parameters
        ----------
        data
            categorie record data specifying what to update
        where
            categorie filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned categorie model

        Returns
        -------
        prisma.models.categorie
            The updated categorie record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        categorie = await categorie.prisma().update(
            where={
                'id': 836760821,
            },
            data={
                # data to update the categorie record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.categorieWhereUniqueInput,
        data: types.categorieUpsertInput,
        include: Optional[types.categorieInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            categorie filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned categorie model

        Returns
        -------
        prisma.models.categorie
            The created or updated categorie record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        categorie = await categorie.prisma().upsert(
            where={
                'id': 595337866,
            },
            data={
                'create': {
                    'id': 595337866,
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.categorieUpdateManyMutationInput,
        where: types.categorieWhereInput,
    ) -> int:
        """Update multiple categorie records

        Parameters
        ----------
        data
            categorie data to update the selected categorie records to
        where
            Filter to select the categorie records to update

        Returns
        -------
        int
            The total number of categorie records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all categorie records
        total = await categorie.prisma().update_many(
            data={
                'id': 790425851
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.categorieWhereInput] = None,
        cursor: Optional[types.categorieWhereUniqueInput] = None,
    ) -> int:
        """Count the number of categorie records present in the database

        Parameters
        ----------
        select
            Select the categorie fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            categorie filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.categorieCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await categorie.prisma().count()

        # results: prisma.types.categorieCountAggregateOutput
        results = await categorie.prisma().count(
            select={
                '_all': True,
                'categorie': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.categorieCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.categorieWhereInput] = None,
        cursor: Optional[types.categorieWhereUniqueInput] = None,
    ) -> types.categorieCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.categorieCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.categorieWhereInput] = None,
        cursor: Optional[types.categorieWhereUniqueInput] = None,
    ) -> Union[int, types.categorieCountAggregateOutput]:
        """Count the number of categorie records present in the database

        Parameters
        ----------
        select
            Select the categorie fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            categorie filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.categorieCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await categorie.prisma().count()

        # results: prisma.types.categorieCountAggregateOutput
        results = await categorie.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.categorieCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.categorieWhereInput] = None
    ) -> int:
        """Delete multiple categorie records.

        Parameters
        ----------
        where
            Optional categorie filter to find the records to be deleted

        Returns
        -------
        int
            The total number of categorie records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all categorie records
        total = await categorie.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.categorieScalarFieldKeys'],
        *,
        where: Optional['types.categorieWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.categorieAvgAggregateInput'] = None,
        sum: Optional['types.categorieSumAggregateInput'] = None,
        min: Optional['types.categorieMinAggregateInput'] = None,
        max: Optional['types.categorieMaxAggregateInput'] = None,
        having: Optional['types.categorieScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.categorieCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.categorieScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.categorieScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.categorieGroupByOutput']:
        """Group categorie records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar categorie fields to group records by
        where
            categorie filter to select records
        take
            Limit the maximum number of categorie records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.categorieGroupByOutput]
            A list of dictionaries representing the categorie record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group categorie records by categorie values
        # and count how many records are in each group
        results = await categorie.prisma().group_by(
            ['categorie'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class categoryclaimsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.categoryclaims]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await categoryclaims.prisma().query_raw(
            'SELECT * FROM categoryclaims WHERE id = ?',
            2111915288,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.categoryclaims
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await categoryclaims.prisma().query_first(
            'SELECT * FROM categoryclaims WHERE claim = ?',
            'bbejhfidcb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.categoryclaimsCreateInput,
        include: Optional[types.categoryclaimsInclude] = None
    ) -> _PrismaModelT:
        """Create a new categoryclaims record.

        Parameters
        ----------
        data
            categoryclaims record data
        include
            Specifies which relations should be loaded on the returned categoryclaims model

        Returns
        -------
        prisma.models.categoryclaims
            The created categoryclaims record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a categoryclaims record from just the required fields
        categoryclaims = await categoryclaims.prisma().create(
            data={
                # data to create a categoryclaims record
                'message': 'bgeecijdgg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.categoryclaimsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple categoryclaims records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of categoryclaims record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await categoryclaims.prisma().create_many(
            data=[
                {
                    # data to create a categoryclaims record
                    'message': 'bdiicjafbj',
                },
                {
                    # data to create a categoryclaims record
                    'message': 'bgehebiafc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.categoryclaimsWhereUniqueInput,
        include: Optional[types.categoryclaimsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single categoryclaims record.

        Parameters
        ----------
        where
            categoryclaims filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned categoryclaims model

        Returns
        -------
        prisma.models.categoryclaims
            The deleted categoryclaims record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        categoryclaims = await categoryclaims.prisma().delete(
            where={
                'id': 1675546029,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.categoryclaimsWhereUniqueInput,
        include: Optional[types.categoryclaimsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique categoryclaims record.

        Parameters
        ----------
        where
            categoryclaims filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned categoryclaims model

        Returns
        -------
        prisma.models.categoryclaims
            The found categoryclaims record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        categoryclaims = await categoryclaims.prisma().find_unique(
            where={
                'id': 1767274722,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.categoryclaimsWhereInput] = None,
        cursor: Optional[types.categoryclaimsWhereUniqueInput] = None,
        include: Optional[types.categoryclaimsInclude] = None,
        order: Optional[Union[types.categoryclaimsOrderByInput, List[types.categoryclaimsOrderByInput]]] = None,
        distinct: Optional[List[types.categoryclaimsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple categoryclaims records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of categoryclaims records returned
        skip
            Ignore the first N results
        where
            categoryclaims filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned categoryclaims model
        order
            Order the returned categoryclaims records by any field
        distinct
            Filter categoryclaims records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.categoryclaims]
            The list of all categoryclaims records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 categoryclaims records
        categoryclaims = await categoryclaims.prisma().find_many(take=10)

        # find the first 5 categoryclaims records ordered by the message field
        categoryclaims = await categoryclaims.prisma().find_many(
            take=5,
            order={
                'message': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.categoryclaimsWhereInput] = None,
        cursor: Optional[types.categoryclaimsWhereUniqueInput] = None,
        include: Optional[types.categoryclaimsInclude] = None,
        order: Optional[Union[types.categoryclaimsOrderByInput, List[types.categoryclaimsOrderByInput]]] = None,
        distinct: Optional[List[types.categoryclaimsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single categoryclaims record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            categoryclaims filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned categoryclaims model
        order
            Order the returned categoryclaims records by any field
        distinct
            Filter categoryclaims records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.categoryclaims
            The first categoryclaims record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second categoryclaims record ordered by the id field
        categoryclaims = await categoryclaims.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.categoryclaimsUpdateInput,
        where: types.categoryclaimsWhereUniqueInput,
        include: Optional[types.categoryclaimsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single categoryclaims record.

        Parameters
        ----------
        data
            categoryclaims record data specifying what to update
        where
            categoryclaims filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned categoryclaims model

        Returns
        -------
        prisma.models.categoryclaims
            The updated categoryclaims record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        categoryclaims = await categoryclaims.prisma().update(
            where={
                'id': 326272115,
            },
            data={
                # data to update the categoryclaims record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.categoryclaimsWhereUniqueInput,
        data: types.categoryclaimsUpsertInput,
        include: Optional[types.categoryclaimsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            categoryclaims filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned categoryclaims model

        Returns
        -------
        prisma.models.categoryclaims
            The created or updated categoryclaims record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        categoryclaims = await categoryclaims.prisma().upsert(
            where={
                'id': 1343201072,
            },
            data={
                'create': {
                    'id': 1343201072,
                    'message': 'bgehebiafc',
                },
                'update': {
                    'message': 'bgehebiafc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.categoryclaimsUpdateManyMutationInput,
        where: types.categoryclaimsWhereInput,
    ) -> int:
        """Update multiple categoryclaims records

        Parameters
        ----------
        data
            categoryclaims data to update the selected categoryclaims records to
        where
            Filter to select the categoryclaims records to update

        Returns
        -------
        int
            The total number of categoryclaims records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all categoryclaims records
        total = await categoryclaims.prisma().update_many(
            data={
                'claim': 'ghfhiafcb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.categoryclaimsWhereInput] = None,
        cursor: Optional[types.categoryclaimsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of categoryclaims records present in the database

        Parameters
        ----------
        select
            Select the categoryclaims fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            categoryclaims filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.categoryclaimsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await categoryclaims.prisma().count()

        # results: prisma.types.categoryclaimsCountAggregateOutput
        results = await categoryclaims.prisma().count(
            select={
                '_all': True,
                'message': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.categoryclaimsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.categoryclaimsWhereInput] = None,
        cursor: Optional[types.categoryclaimsWhereUniqueInput] = None,
    ) -> types.categoryclaimsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.categoryclaimsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.categoryclaimsWhereInput] = None,
        cursor: Optional[types.categoryclaimsWhereUniqueInput] = None,
    ) -> Union[int, types.categoryclaimsCountAggregateOutput]:
        """Count the number of categoryclaims records present in the database

        Parameters
        ----------
        select
            Select the categoryclaims fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            categoryclaims filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.categoryclaimsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await categoryclaims.prisma().count()

        # results: prisma.types.categoryclaimsCountAggregateOutput
        results = await categoryclaims.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.categoryclaimsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.categoryclaimsWhereInput] = None
    ) -> int:
        """Delete multiple categoryclaims records.

        Parameters
        ----------
        where
            Optional categoryclaims filter to find the records to be deleted

        Returns
        -------
        int
            The total number of categoryclaims records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all categoryclaims records
        total = await categoryclaims.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.categoryclaimsScalarFieldKeys'],
        *,
        where: Optional['types.categoryclaimsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.categoryclaimsAvgAggregateInput'] = None,
        sum: Optional['types.categoryclaimsSumAggregateInput'] = None,
        min: Optional['types.categoryclaimsMinAggregateInput'] = None,
        max: Optional['types.categoryclaimsMaxAggregateInput'] = None,
        having: Optional['types.categoryclaimsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.categoryclaimsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.categoryclaimsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.categoryclaimsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.categoryclaimsGroupByOutput']:
        """Group categoryclaims records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar categoryclaims fields to group records by
        where
            categoryclaims filter to select records
        take
            Limit the maximum number of categoryclaims records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.categoryclaimsGroupByOutput]
            A list of dictionaries representing the categoryclaims record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group categoryclaims records by claim values
        # and count how many records are in each group
        results = await categoryclaims.prisma().group_by(
            ['claim'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class categoryrecetteActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.categoryrecette]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await categoryrecette.prisma().query_raw(
            'SELECT * FROM categoryrecette WHERE id = ?',
            744964398,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.categoryrecette
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await categoryrecette.prisma().query_first(
            'SELECT * FROM categoryrecette WHERE description = ?',
            'bjgjgibgbf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.categoryrecetteCreateInput,
        include: Optional[types.categoryrecetteInclude] = None
    ) -> _PrismaModelT:
        """Create a new categoryrecette record.

        Parameters
        ----------
        data
            categoryrecette record data
        include
            Specifies which relations should be loaded on the returned categoryrecette model

        Returns
        -------
        prisma.models.categoryrecette
            The created categoryrecette record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a categoryrecette record from just the required fields
        categoryrecette = await categoryrecette.prisma().create(
            data={
                # data to create a categoryrecette record
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.categoryrecetteCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple categoryrecette records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of categoryrecette record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await categoryrecette.prisma().create_many(
            data=[
                {
                    # data to create a categoryrecette record
                },
                {
                    # data to create a categoryrecette record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.categoryrecetteWhereUniqueInput,
        include: Optional[types.categoryrecetteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single categoryrecette record.

        Parameters
        ----------
        where
            categoryrecette filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned categoryrecette model

        Returns
        -------
        prisma.models.categoryrecette
            The deleted categoryrecette record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        categoryrecette = await categoryrecette.prisma().delete(
            where={
                'id': 1116175964,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.categoryrecetteWhereUniqueInput,
        include: Optional[types.categoryrecetteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique categoryrecette record.

        Parameters
        ----------
        where
            categoryrecette filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned categoryrecette model

        Returns
        -------
        prisma.models.categoryrecette
            The found categoryrecette record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        categoryrecette = await categoryrecette.prisma().find_unique(
            where={
                'id': 861472101,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.categoryrecetteWhereInput] = None,
        cursor: Optional[types.categoryrecetteWhereUniqueInput] = None,
        include: Optional[types.categoryrecetteInclude] = None,
        order: Optional[Union[types.categoryrecetteOrderByInput, List[types.categoryrecetteOrderByInput]]] = None,
        distinct: Optional[List[types.categoryrecetteScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple categoryrecette records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of categoryrecette records returned
        skip
            Ignore the first N results
        where
            categoryrecette filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned categoryrecette model
        order
            Order the returned categoryrecette records by any field
        distinct
            Filter categoryrecette records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.categoryrecette]
            The list of all categoryrecette records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 categoryrecette records
        categoryrecettes = await categoryrecette.prisma().find_many(take=10)

        # find the first 5 categoryrecette records ordered by the id field
        categoryrecettes = await categoryrecette.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.categoryrecetteWhereInput] = None,
        cursor: Optional[types.categoryrecetteWhereUniqueInput] = None,
        include: Optional[types.categoryrecetteInclude] = None,
        order: Optional[Union[types.categoryrecetteOrderByInput, List[types.categoryrecetteOrderByInput]]] = None,
        distinct: Optional[List[types.categoryrecetteScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single categoryrecette record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            categoryrecette filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned categoryrecette model
        order
            Order the returned categoryrecette records by any field
        distinct
            Filter categoryrecette records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.categoryrecette
            The first categoryrecette record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second categoryrecette record ordered by the description field
        categoryrecette = await categoryrecette.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.categoryrecetteUpdateInput,
        where: types.categoryrecetteWhereUniqueInput,
        include: Optional[types.categoryrecetteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single categoryrecette record.

        Parameters
        ----------
        data
            categoryrecette record data specifying what to update
        where
            categoryrecette filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned categoryrecette model

        Returns
        -------
        prisma.models.categoryrecette
            The updated categoryrecette record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        categoryrecette = await categoryrecette.prisma().update(
            where={
                'id': 1303003706,
            },
            data={
                # data to update the categoryrecette record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.categoryrecetteWhereUniqueInput,
        data: types.categoryrecetteUpsertInput,
        include: Optional[types.categoryrecetteInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            categoryrecette filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned categoryrecette model

        Returns
        -------
        prisma.models.categoryrecette
            The created or updated categoryrecette record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        categoryrecette = await categoryrecette.prisma().upsert(
            where={
                'id': 1686638315,
            },
            data={
                'create': {
                    'id': 1686638315,
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.categoryrecetteUpdateManyMutationInput,
        where: types.categoryrecetteWhereInput,
    ) -> int:
        """Update multiple categoryrecette records

        Parameters
        ----------
        data
            categoryrecette data to update the selected categoryrecette records to
        where
            Filter to select the categoryrecette records to update

        Returns
        -------
        int
            The total number of categoryrecette records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all categoryrecette records
        total = await categoryrecette.prisma().update_many(
            data={
                'id': 2000430152
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.categoryrecetteWhereInput] = None,
        cursor: Optional[types.categoryrecetteWhereUniqueInput] = None,
    ) -> int:
        """Count the number of categoryrecette records present in the database

        Parameters
        ----------
        select
            Select the categoryrecette fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            categoryrecette filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.categoryrecetteCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await categoryrecette.prisma().count()

        # results: prisma.types.categoryrecetteCountAggregateOutput
        results = await categoryrecette.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.categoryrecetteCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.categoryrecetteWhereInput] = None,
        cursor: Optional[types.categoryrecetteWhereUniqueInput] = None,
    ) -> types.categoryrecetteCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.categoryrecetteCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.categoryrecetteWhereInput] = None,
        cursor: Optional[types.categoryrecetteWhereUniqueInput] = None,
    ) -> Union[int, types.categoryrecetteCountAggregateOutput]:
        """Count the number of categoryrecette records present in the database

        Parameters
        ----------
        select
            Select the categoryrecette fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            categoryrecette filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.categoryrecetteCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await categoryrecette.prisma().count()

        # results: prisma.types.categoryrecetteCountAggregateOutput
        results = await categoryrecette.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.categoryrecetteCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.categoryrecetteWhereInput] = None
    ) -> int:
        """Delete multiple categoryrecette records.

        Parameters
        ----------
        where
            Optional categoryrecette filter to find the records to be deleted

        Returns
        -------
        int
            The total number of categoryrecette records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all categoryrecette records
        total = await categoryrecette.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.categoryrecetteScalarFieldKeys'],
        *,
        where: Optional['types.categoryrecetteWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.categoryrecetteAvgAggregateInput'] = None,
        sum: Optional['types.categoryrecetteSumAggregateInput'] = None,
        min: Optional['types.categoryrecetteMinAggregateInput'] = None,
        max: Optional['types.categoryrecetteMaxAggregateInput'] = None,
        having: Optional['types.categoryrecetteScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.categoryrecetteCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.categoryrecetteScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.categoryrecetteScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.categoryrecetteGroupByOutput']:
        """Group categoryrecette records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar categoryrecette fields to group records by
        where
            categoryrecette filter to select records
        take
            Limit the maximum number of categoryrecette records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.categoryrecetteGroupByOutput]
            A list of dictionaries representing the categoryrecette record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group categoryrecette records by description values
        # and count how many records are in each group
        results = await categoryrecette.prisma().group_by(
            ['description'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class categorysensorsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.categorysensors]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await categorysensors.prisma().query_raw(
            'SELECT * FROM categorysensors WHERE id = ?',
            1868141281,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.categorysensors
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await categorysensors.prisma().query_first(
            'SELECT * FROM categorysensors WHERE sensor = ?',
            'bigaiehgcc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.categorysensorsCreateInput,
        include: Optional[types.categorysensorsInclude] = None
    ) -> _PrismaModelT:
        """Create a new categorysensors record.

        Parameters
        ----------
        data
            categorysensors record data
        include
            Specifies which relations should be loaded on the returned categorysensors model

        Returns
        -------
        prisma.models.categorysensors
            The created categorysensors record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a categorysensors record from just the required fields
        categorysensors = await categorysensors.prisma().create(
            data={
                # data to create a categorysensors record
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.categorysensorsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple categorysensors records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of categorysensors record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await categorysensors.prisma().create_many(
            data=[
                {
                    # data to create a categorysensors record
                },
                {
                    # data to create a categorysensors record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.categorysensorsWhereUniqueInput,
        include: Optional[types.categorysensorsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single categorysensors record.

        Parameters
        ----------
        where
            categorysensors filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned categorysensors model

        Returns
        -------
        prisma.models.categorysensors
            The deleted categorysensors record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        categorysensors = await categorysensors.prisma().delete(
            where={
                'id': 1448521415,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.categorysensorsWhereUniqueInput,
        include: Optional[types.categorysensorsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique categorysensors record.

        Parameters
        ----------
        where
            categorysensors filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned categorysensors model

        Returns
        -------
        prisma.models.categorysensors
            The found categorysensors record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        categorysensors = await categorysensors.prisma().find_unique(
            where={
                'id': 1628650740,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.categorysensorsWhereInput] = None,
        cursor: Optional[types.categorysensorsWhereUniqueInput] = None,
        include: Optional[types.categorysensorsInclude] = None,
        order: Optional[Union[types.categorysensorsOrderByInput, List[types.categorysensorsOrderByInput]]] = None,
        distinct: Optional[List[types.categorysensorsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple categorysensors records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of categorysensors records returned
        skip
            Ignore the first N results
        where
            categorysensors filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned categorysensors model
        order
            Order the returned categorysensors records by any field
        distinct
            Filter categorysensors records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.categorysensors]
            The list of all categorysensors records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 categorysensors records
        categorysensors = await categorysensors.prisma().find_many(take=10)

        # find the first 5 categorysensors records ordered by the security field
        categorysensors = await categorysensors.prisma().find_many(
            take=5,
            order={
                'security': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.categorysensorsWhereInput] = None,
        cursor: Optional[types.categorysensorsWhereUniqueInput] = None,
        include: Optional[types.categorysensorsInclude] = None,
        order: Optional[Union[types.categorysensorsOrderByInput, List[types.categorysensorsOrderByInput]]] = None,
        distinct: Optional[List[types.categorysensorsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single categorysensors record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            categorysensors filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned categorysensors model
        order
            Order the returned categorysensors records by any field
        distinct
            Filter categorysensors records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.categorysensors
            The first categorysensors record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second categorysensors record ordered by the id field
        categorysensors = await categorysensors.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.categorysensorsUpdateInput,
        where: types.categorysensorsWhereUniqueInput,
        include: Optional[types.categorysensorsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single categorysensors record.

        Parameters
        ----------
        data
            categorysensors record data specifying what to update
        where
            categorysensors filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned categorysensors model

        Returns
        -------
        prisma.models.categorysensors
            The updated categorysensors record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        categorysensors = await categorysensors.prisma().update(
            where={
                'id': 1249606685,
            },
            data={
                # data to update the categorysensors record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.categorysensorsWhereUniqueInput,
        data: types.categorysensorsUpsertInput,
        include: Optional[types.categorysensorsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            categorysensors filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned categorysensors model

        Returns
        -------
        prisma.models.categorysensors
            The created or updated categorysensors record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        categorysensors = await categorysensors.prisma().upsert(
            where={
                'id': 835903122,
            },
            data={
                'create': {
                    'id': 835903122,
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.categorysensorsUpdateManyMutationInput,
        where: types.categorysensorsWhereInput,
    ) -> int:
        """Update multiple categorysensors records

        Parameters
        ----------
        data
            categorysensors data to update the selected categorysensors records to
        where
            Filter to select the categorysensors records to update

        Returns
        -------
        int
            The total number of categorysensors records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all categorysensors records
        total = await categorysensors.prisma().update_many(
            data={
                'sensor': 'hgdhbjhhj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.categorysensorsWhereInput] = None,
        cursor: Optional[types.categorysensorsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of categorysensors records present in the database

        Parameters
        ----------
        select
            Select the categorysensors fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            categorysensors filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.categorysensorsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await categorysensors.prisma().count()

        # results: prisma.types.categorysensorsCountAggregateOutput
        results = await categorysensors.prisma().count(
            select={
                '_all': True,
                'security': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.categorysensorsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.categorysensorsWhereInput] = None,
        cursor: Optional[types.categorysensorsWhereUniqueInput] = None,
    ) -> types.categorysensorsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.categorysensorsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.categorysensorsWhereInput] = None,
        cursor: Optional[types.categorysensorsWhereUniqueInput] = None,
    ) -> Union[int, types.categorysensorsCountAggregateOutput]:
        """Count the number of categorysensors records present in the database

        Parameters
        ----------
        select
            Select the categorysensors fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            categorysensors filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.categorysensorsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await categorysensors.prisma().count()

        # results: prisma.types.categorysensorsCountAggregateOutput
        results = await categorysensors.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.categorysensorsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.categorysensorsWhereInput] = None
    ) -> int:
        """Delete multiple categorysensors records.

        Parameters
        ----------
        where
            Optional categorysensors filter to find the records to be deleted

        Returns
        -------
        int
            The total number of categorysensors records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all categorysensors records
        total = await categorysensors.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.categorysensorsScalarFieldKeys'],
        *,
        where: Optional['types.categorysensorsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.categorysensorsAvgAggregateInput'] = None,
        sum: Optional['types.categorysensorsSumAggregateInput'] = None,
        min: Optional['types.categorysensorsMinAggregateInput'] = None,
        max: Optional['types.categorysensorsMaxAggregateInput'] = None,
        having: Optional['types.categorysensorsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.categorysensorsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.categorysensorsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.categorysensorsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.categorysensorsGroupByOutput']:
        """Group categorysensors records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar categorysensors fields to group records by
        where
            categorysensors filter to select records
        take
            Limit the maximum number of categorysensors records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.categorysensorsGroupByOutput]
            A list of dictionaries representing the categorysensors record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group categorysensors records by sensor values
        # and count how many records are in each group
        results = await categorysensors.prisma().group_by(
            ['sensor'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class commandeActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.commande]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await commande.prisma().query_raw(
            'SELECT * FROM commande WHERE id = ?',
            429995104,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.commande
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await commande.prisma().query_first(
            'SELECT * FROM commande WHERE idRecette = ?',
            1775811865,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.commandeCreateInput,
        include: Optional[types.commandeInclude] = None
    ) -> _PrismaModelT:
        """Create a new commande record.

        Parameters
        ----------
        data
            commande record data
        include
            Specifies which relations should be loaded on the returned commande model

        Returns
        -------
        prisma.models.commande
            The created commande record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a commande record from just the required fields
        commande = await commande.prisma().create(
            data={
                # data to create a commande record
                'idRecette': 893145566,
                'quantity': 'jjfeafhfj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.commandeCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple commande records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of commande record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await commande.prisma().create_many(
            data=[
                {
                    # data to create a commande record
                    'idRecette': 2102736524,
                    'quantity': 'chbfcacbd',
                },
                {
                    # data to create a commande record
                    'idRecette': 456633834,
                    'quantity': 'caficfigfb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.commandeWhereUniqueInput,
        include: Optional[types.commandeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single commande record.

        Parameters
        ----------
        where
            commande filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned commande model

        Returns
        -------
        prisma.models.commande
            The deleted commande record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        commande = await commande.prisma().delete(
            where={
                'id': 1583689592,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.commandeWhereUniqueInput,
        include: Optional[types.commandeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique commande record.

        Parameters
        ----------
        where
            commande filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned commande model

        Returns
        -------
        prisma.models.commande
            The found commande record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        commande = await commande.prisma().find_unique(
            where={
                'id': 878442065,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.commandeWhereInput] = None,
        cursor: Optional[types.commandeWhereUniqueInput] = None,
        include: Optional[types.commandeInclude] = None,
        order: Optional[Union[types.commandeOrderByInput, List[types.commandeOrderByInput]]] = None,
        distinct: Optional[List[types.commandeScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple commande records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of commande records returned
        skip
            Ignore the first N results
        where
            commande filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned commande model
        order
            Order the returned commande records by any field
        distinct
            Filter commande records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.commande]
            The list of all commande records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 commande records
        commandes = await commande.prisma().find_many(take=10)

        # find the first 5 commande records ordered by the idIngredient field
        commandes = await commande.prisma().find_many(
            take=5,
            order={
                'idIngredient': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.commandeWhereInput] = None,
        cursor: Optional[types.commandeWhereUniqueInput] = None,
        include: Optional[types.commandeInclude] = None,
        order: Optional[Union[types.commandeOrderByInput, List[types.commandeOrderByInput]]] = None,
        distinct: Optional[List[types.commandeScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single commande record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            commande filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned commande model
        order
            Order the returned commande records by any field
        distinct
            Filter commande records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.commande
            The first commande record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second commande record ordered by the quantity field
        commande = await commande.prisma().find_first(
            skip=1,
            order={
                'quantity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.commandeUpdateInput,
        where: types.commandeWhereUniqueInput,
        include: Optional[types.commandeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single commande record.

        Parameters
        ----------
        data
            commande record data specifying what to update
        where
            commande filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned commande model

        Returns
        -------
        prisma.models.commande
            The updated commande record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        commande = await commande.prisma().update(
            where={
                'id': 1675280054,
            },
            data={
                # data to update the commande record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.commandeWhereUniqueInput,
        data: types.commandeUpsertInput,
        include: Optional[types.commandeInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            commande filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned commande model

        Returns
        -------
        prisma.models.commande
            The created or updated commande record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        commande = await commande.prisma().upsert(
            where={
                'id': 1627576247,
            },
            data={
                'create': {
                    'id': 1627576247,
                    'idRecette': 456633834,
                    'quantity': 'caficfigfb',
                },
                'update': {
                    'idRecette': 456633834,
                    'quantity': 'caficfigfb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.commandeUpdateManyMutationInput,
        where: types.commandeWhereInput,
    ) -> int:
        """Update multiple commande records

        Parameters
        ----------
        data
            commande data to update the selected commande records to
        where
            Filter to select the commande records to update

        Returns
        -------
        int
            The total number of commande records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all commande records
        total = await commande.prisma().update_many(
            data={
                'id': 2054802212
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.commandeWhereInput] = None,
        cursor: Optional[types.commandeWhereUniqueInput] = None,
    ) -> int:
        """Count the number of commande records present in the database

        Parameters
        ----------
        select
            Select the commande fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            commande filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.commandeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await commande.prisma().count()

        # results: prisma.types.commandeCountAggregateOutput
        results = await commande.prisma().count(
            select={
                '_all': True,
                'idRecette': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.commandeCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.commandeWhereInput] = None,
        cursor: Optional[types.commandeWhereUniqueInput] = None,
    ) -> types.commandeCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.commandeCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.commandeWhereInput] = None,
        cursor: Optional[types.commandeWhereUniqueInput] = None,
    ) -> Union[int, types.commandeCountAggregateOutput]:
        """Count the number of commande records present in the database

        Parameters
        ----------
        select
            Select the commande fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            commande filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.commandeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await commande.prisma().count()

        # results: prisma.types.commandeCountAggregateOutput
        results = await commande.prisma().count(
            select={
                '_all': True,
                'idIngredient': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.commandeCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.commandeWhereInput] = None
    ) -> int:
        """Delete multiple commande records.

        Parameters
        ----------
        where
            Optional commande filter to find the records to be deleted

        Returns
        -------
        int
            The total number of commande records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all commande records
        total = await commande.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.commandeScalarFieldKeys'],
        *,
        where: Optional['types.commandeWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.commandeAvgAggregateInput'] = None,
        sum: Optional['types.commandeSumAggregateInput'] = None,
        min: Optional['types.commandeMinAggregateInput'] = None,
        max: Optional['types.commandeMaxAggregateInput'] = None,
        having: Optional['types.commandeScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.commandeCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.commandeScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.commandeScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.commandeGroupByOutput']:
        """Group commande records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar commande fields to group records by
        where
            commande filter to select records
        take
            Limit the maximum number of commande records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.commandeGroupByOutput]
            A list of dictionaries representing the commande record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group commande records by quantity values
        # and count how many records are in each group
        results = await commande.prisma().group_by(
            ['quantity'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class distributeurActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.distributeur]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await distributeur.prisma().query_raw(
            'SELECT * FROM distributeur WHERE id = ?',
            60335757,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.distributeur
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await distributeur.prisma().query_first(
            'SELECT * FROM distributeur WHERE identifiant = ?',
            'gieegcbeg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.distributeurCreateInput,
        include: Optional[types.distributeurInclude] = None
    ) -> _PrismaModelT:
        """Create a new distributeur record.

        Parameters
        ----------
        data
            distributeur record data
        include
            Specifies which relations should be loaded on the returned distributeur model

        Returns
        -------
        prisma.models.distributeur
            The created distributeur record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a distributeur record from just the required fields
        distributeur = await distributeur.prisma().create(
            data={
                # data to create a distributeur record
                'identifiant': 'bgcffadich',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.distributeurCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple distributeur records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of distributeur record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await distributeur.prisma().create_many(
            data=[
                {
                    # data to create a distributeur record
                    'identifiant': 'fcbichhci',
                },
                {
                    # data to create a distributeur record
                    'identifiant': 'bcggadccgf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.distributeurWhereUniqueInput,
        include: Optional[types.distributeurInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single distributeur record.

        Parameters
        ----------
        where
            distributeur filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned distributeur model

        Returns
        -------
        prisma.models.distributeur
            The deleted distributeur record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        distributeur = await distributeur.prisma().delete(
            where={
                'id': 93253262,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.distributeurWhereUniqueInput,
        include: Optional[types.distributeurInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique distributeur record.

        Parameters
        ----------
        where
            distributeur filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned distributeur model

        Returns
        -------
        prisma.models.distributeur
            The found distributeur record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        distributeur = await distributeur.prisma().find_unique(
            where={
                'id': 2053047983,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.distributeurWhereInput] = None,
        cursor: Optional[types.distributeurWhereUniqueInput] = None,
        include: Optional[types.distributeurInclude] = None,
        order: Optional[Union[types.distributeurOrderByInput, List[types.distributeurOrderByInput]]] = None,
        distinct: Optional[List[types.distributeurScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple distributeur records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of distributeur records returned
        skip
            Ignore the first N results
        where
            distributeur filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned distributeur model
        order
            Order the returned distributeur records by any field
        distinct
            Filter distributeur records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.distributeur]
            The list of all distributeur records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 distributeur records
        distributeurs = await distributeur.prisma().find_many(take=10)

        # find the first 5 distributeur records ordered by the capaciteGoblet field
        distributeurs = await distributeur.prisma().find_many(
            take=5,
            order={
                'capaciteGoblet': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.distributeurWhereInput] = None,
        cursor: Optional[types.distributeurWhereUniqueInput] = None,
        include: Optional[types.distributeurInclude] = None,
        order: Optional[Union[types.distributeurOrderByInput, List[types.distributeurOrderByInput]]] = None,
        distinct: Optional[List[types.distributeurScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single distributeur record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            distributeur filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned distributeur model
        order
            Order the returned distributeur records by any field
        distinct
            Filter distributeur records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.distributeur
            The first distributeur record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second distributeur record ordered by the capaciteSucre field
        distributeur = await distributeur.prisma().find_first(
            skip=1,
            order={
                'capaciteSucre': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.distributeurUpdateInput,
        where: types.distributeurWhereUniqueInput,
        include: Optional[types.distributeurInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single distributeur record.

        Parameters
        ----------
        data
            distributeur record data specifying what to update
        where
            distributeur filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned distributeur model

        Returns
        -------
        prisma.models.distributeur
            The updated distributeur record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        distributeur = await distributeur.prisma().update(
            where={
                'id': 685333180,
            },
            data={
                # data to update the distributeur record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.distributeurWhereUniqueInput,
        data: types.distributeurUpsertInput,
        include: Optional[types.distributeurInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            distributeur filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned distributeur model

        Returns
        -------
        prisma.models.distributeur
            The created or updated distributeur record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        distributeur = await distributeur.prisma().upsert(
            where={
                'id': 127474245,
            },
            data={
                'create': {
                    'id': 127474245,
                    'identifiant': 'bcggadccgf',
                },
                'update': {
                    'identifiant': 'bcggadccgf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.distributeurUpdateManyMutationInput,
        where: types.distributeurWhereInput,
    ) -> int:
        """Update multiple distributeur records

        Parameters
        ----------
        data
            distributeur data to update the selected distributeur records to
        where
            Filter to select the distributeur records to update

        Returns
        -------
        int
            The total number of distributeur records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all distributeur records
        total = await distributeur.prisma().update_many(
            data={
                'capaciteSpoon': 948921754
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.distributeurWhereInput] = None,
        cursor: Optional[types.distributeurWhereUniqueInput] = None,
    ) -> int:
        """Count the number of distributeur records present in the database

        Parameters
        ----------
        select
            Select the distributeur fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            distributeur filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.distributeurCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await distributeur.prisma().count()

        # results: prisma.types.distributeurCountAggregateOutput
        results = await distributeur.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.distributeurCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.distributeurWhereInput] = None,
        cursor: Optional[types.distributeurWhereUniqueInput] = None,
    ) -> types.distributeurCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.distributeurCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.distributeurWhereInput] = None,
        cursor: Optional[types.distributeurWhereUniqueInput] = None,
    ) -> Union[int, types.distributeurCountAggregateOutput]:
        """Count the number of distributeur records present in the database

        Parameters
        ----------
        select
            Select the distributeur fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            distributeur filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.distributeurCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await distributeur.prisma().count()

        # results: prisma.types.distributeurCountAggregateOutput
        results = await distributeur.prisma().count(
            select={
                '_all': True,
                'identifiant': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.distributeurCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.distributeurWhereInput] = None
    ) -> int:
        """Delete multiple distributeur records.

        Parameters
        ----------
        where
            Optional distributeur filter to find the records to be deleted

        Returns
        -------
        int
            The total number of distributeur records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all distributeur records
        total = await distributeur.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.distributeurScalarFieldKeys'],
        *,
        where: Optional['types.distributeurWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.distributeurAvgAggregateInput'] = None,
        sum: Optional['types.distributeurSumAggregateInput'] = None,
        min: Optional['types.distributeurMinAggregateInput'] = None,
        max: Optional['types.distributeurMaxAggregateInput'] = None,
        having: Optional['types.distributeurScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.distributeurCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.distributeurScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.distributeurScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.distributeurGroupByOutput']:
        """Group distributeur records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar distributeur fields to group records by
        where
            distributeur filter to select records
        take
            Limit the maximum number of distributeur records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.distributeurGroupByOutput]
            A list of dictionaries representing the distributeur record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group distributeur records by capaciteGoblet values
        # and count how many records are in each group
        results = await distributeur.prisma().group_by(
            ['capaciteGoblet'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class distributeurRecetteActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.distributeurRecette]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await distributeurRecette.prisma().query_raw(
            'SELECT * FROM distributeurRecette WHERE idDistr = ?',
            1964990155,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.distributeurRecette
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await distributeurRecette.prisma().query_first(
            'SELECT * FROM distributeurRecette WHERE idRecette = ?',
            1228891816,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.distributeurRecetteCreateInput,
        include: Optional[types.distributeurRecetteInclude] = None
    ) -> _PrismaModelT:
        """Create a new distributeurRecette record.

        Parameters
        ----------
        data
            distributeurRecette record data
        include
            Specifies which relations should be loaded on the returned distributeurRecette model

        Returns
        -------
        prisma.models.distributeurRecette
            The created distributeurRecette record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a distributeurRecette record from just the required fields
        distributeurrecette = await distributeurRecette.prisma().create(
            data={
                # data to create a distributeurRecette record
                'idDistr': 255202753,
                'idRecette': 1223573862,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.distributeurRecetteCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple distributeurRecette records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of distributeurRecette record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await distributeurRecette.prisma().create_many(
            data=[
                {
                    # data to create a distributeurRecette record
                    'idDistr': 541269159,
                    'idRecette': 1064846676,
                },
                {
                    # data to create a distributeurRecette record
                    'idDistr': 508382461,
                    'idRecette': 1024265714,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.distributeurRecetteWhereUniqueInput,
        include: Optional[types.distributeurRecetteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single distributeurRecette record.

        Parameters
        ----------
        where
            distributeurRecette filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned distributeurRecette model

        Returns
        -------
        prisma.models.distributeurRecette
            The deleted distributeurRecette record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        distributeurrecette = await distributeurRecette.prisma().delete(
            where={
                # distributeurRecette where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.distributeurRecetteWhereUniqueInput,
        include: Optional[types.distributeurRecetteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique distributeurRecette record.

        Parameters
        ----------
        where
            distributeurRecette filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned distributeurRecette model

        Returns
        -------
        prisma.models.distributeurRecette
            The found distributeurRecette record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        distributeurrecette = await distributeurRecette.prisma().find_unique(
            where={
                # distributeurRecette where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.distributeurRecetteWhereInput] = None,
        cursor: Optional[types.distributeurRecetteWhereUniqueInput] = None,
        include: Optional[types.distributeurRecetteInclude] = None,
        order: Optional[Union[types.distributeurRecetteOrderByInput, List[types.distributeurRecetteOrderByInput]]] = None,
        distinct: Optional[List[types.distributeurRecetteScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple distributeurRecette records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of distributeurRecette records returned
        skip
            Ignore the first N results
        where
            distributeurRecette filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned distributeurRecette model
        order
            Order the returned distributeurRecette records by any field
        distinct
            Filter distributeurRecette records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.distributeurRecette]
            The list of all distributeurRecette records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 distributeurRecette records
        distributeurrecettes = await distributeurRecette.prisma().find_many(take=10)

        # find the first 5 distributeurRecette records ordered by the price field
        distributeurrecettes = await distributeurRecette.prisma().find_many(
            take=5,
            order={
                'price': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.distributeurRecetteWhereInput] = None,
        cursor: Optional[types.distributeurRecetteWhereUniqueInput] = None,
        include: Optional[types.distributeurRecetteInclude] = None,
        order: Optional[Union[types.distributeurRecetteOrderByInput, List[types.distributeurRecetteOrderByInput]]] = None,
        distinct: Optional[List[types.distributeurRecetteScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single distributeurRecette record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            distributeurRecette filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned distributeurRecette model
        order
            Order the returned distributeurRecette records by any field
        distinct
            Filter distributeurRecette records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.distributeurRecette
            The first distributeurRecette record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second distributeurRecette record ordered by the idDistr field
        distributeurrecette = await distributeurRecette.prisma().find_first(
            skip=1,
            order={
                'idDistr': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.distributeurRecetteUpdateInput,
        where: types.distributeurRecetteWhereUniqueInput,
        include: Optional[types.distributeurRecetteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single distributeurRecette record.

        Parameters
        ----------
        data
            distributeurRecette record data specifying what to update
        where
            distributeurRecette filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned distributeurRecette model

        Returns
        -------
        prisma.models.distributeurRecette
            The updated distributeurRecette record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        distributeurrecette = await distributeurRecette.prisma().update(
            where={
                # distributeurRecette where unique filter

            },
            data={
                # data to update the distributeurRecette record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.distributeurRecetteWhereUniqueInput,
        data: types.distributeurRecetteUpsertInput,
        include: Optional[types.distributeurRecetteInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            distributeurRecette filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned distributeurRecette model

        Returns
        -------
        prisma.models.distributeurRecette
            The created or updated distributeurRecette record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        distributeurrecette = await distributeurRecette.prisma().upsert(
            where={
                # distributeurRecette where unique filter
            },
            data={
                'create': {
                    # distributeurRecette data to be set if the record does not exist
                },
                'update': {
                    # distributeurRecette data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.distributeurRecetteUpdateManyMutationInput,
        where: types.distributeurRecetteWhereInput,
    ) -> int:
        """Update multiple distributeurRecette records

        Parameters
        ----------
        data
            distributeurRecette data to update the selected distributeurRecette records to
        where
            Filter to select the distributeurRecette records to update

        Returns
        -------
        int
            The total number of distributeurRecette records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all distributeurRecette records
        total = await distributeurRecette.prisma().update_many(
            data={
                'idRecette': 872078403
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.distributeurRecetteWhereInput] = None,
        cursor: Optional[types.distributeurRecetteWhereUniqueInput] = None,
    ) -> int:
        """Count the number of distributeurRecette records present in the database

        Parameters
        ----------
        select
            Select the distributeurRecette fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            distributeurRecette filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.distributeurRecetteCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await distributeurRecette.prisma().count()

        # results: prisma.types.distributeurRecetteCountAggregateOutput
        results = await distributeurRecette.prisma().count(
            select={
                '_all': True,
                'price': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.distributeurRecetteCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.distributeurRecetteWhereInput] = None,
        cursor: Optional[types.distributeurRecetteWhereUniqueInput] = None,
    ) -> types.distributeurRecetteCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.distributeurRecetteCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.distributeurRecetteWhereInput] = None,
        cursor: Optional[types.distributeurRecetteWhereUniqueInput] = None,
    ) -> Union[int, types.distributeurRecetteCountAggregateOutput]:
        """Count the number of distributeurRecette records present in the database

        Parameters
        ----------
        select
            Select the distributeurRecette fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            distributeurRecette filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.distributeurRecetteCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await distributeurRecette.prisma().count()

        # results: prisma.types.distributeurRecetteCountAggregateOutput
        results = await distributeurRecette.prisma().count(
            select={
                '_all': True,
                'idDistr': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.distributeurRecetteCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.distributeurRecetteWhereInput] = None
    ) -> int:
        """Delete multiple distributeurRecette records.

        Parameters
        ----------
        where
            Optional distributeurRecette filter to find the records to be deleted

        Returns
        -------
        int
            The total number of distributeurRecette records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all distributeurRecette records
        total = await distributeurRecette.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.distributeurRecetteScalarFieldKeys'],
        *,
        where: Optional['types.distributeurRecetteWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.distributeurRecetteAvgAggregateInput'] = None,
        sum: Optional['types.distributeurRecetteSumAggregateInput'] = None,
        min: Optional['types.distributeurRecetteMinAggregateInput'] = None,
        max: Optional['types.distributeurRecetteMaxAggregateInput'] = None,
        having: Optional['types.distributeurRecetteScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.distributeurRecetteCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.distributeurRecetteScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.distributeurRecetteScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.distributeurRecetteGroupByOutput']:
        """Group distributeurRecette records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar distributeurRecette fields to group records by
        where
            distributeurRecette filter to select records
        take
            Limit the maximum number of distributeurRecette records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.distributeurRecetteGroupByOutput]
            A list of dictionaries representing the distributeurRecette record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group distributeurRecette records by idRecette values
        # and count how many records are in each group
        results = await distributeurRecette.prisma().group_by(
            ['idRecette'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class entrepiseActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.entrepise]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await entrepise.prisma().query_raw(
            'SELECT * FROM entrepise WHERE id = ?',
            1874748096,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.entrepise
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await entrepise.prisma().query_first(
            'SELECT * FROM entrepise WHERE nom = ?',
            'jbgijghgb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.entrepiseCreateInput,
        include: Optional[types.entrepiseInclude] = None
    ) -> _PrismaModelT:
        """Create a new entrepise record.

        Parameters
        ----------
        data
            entrepise record data
        include
            Specifies which relations should be loaded on the returned entrepise model

        Returns
        -------
        prisma.models.entrepise
            The created entrepise record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a entrepise record from just the required fields
        entrepise = await entrepise.prisma().create(
            data={
                # data to create a entrepise record
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.entrepiseCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple entrepise records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of entrepise record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await entrepise.prisma().create_many(
            data=[
                {
                    # data to create a entrepise record
                },
                {
                    # data to create a entrepise record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.entrepiseWhereUniqueInput,
        include: Optional[types.entrepiseInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single entrepise record.

        Parameters
        ----------
        where
            entrepise filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned entrepise model

        Returns
        -------
        prisma.models.entrepise
            The deleted entrepise record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        entrepise = await entrepise.prisma().delete(
            where={
                'id': 769267518,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.entrepiseWhereUniqueInput,
        include: Optional[types.entrepiseInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique entrepise record.

        Parameters
        ----------
        where
            entrepise filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned entrepise model

        Returns
        -------
        prisma.models.entrepise
            The found entrepise record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        entrepise = await entrepise.prisma().find_unique(
            where={
                'id': 820312479,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.entrepiseWhereInput] = None,
        cursor: Optional[types.entrepiseWhereUniqueInput] = None,
        include: Optional[types.entrepiseInclude] = None,
        order: Optional[Union[types.entrepiseOrderByInput, List[types.entrepiseOrderByInput]]] = None,
        distinct: Optional[List[types.entrepiseScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple entrepise records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of entrepise records returned
        skip
            Ignore the first N results
        where
            entrepise filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned entrepise model
        order
            Order the returned entrepise records by any field
        distinct
            Filter entrepise records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.entrepise]
            The list of all entrepise records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 entrepise records
        entrepises = await entrepise.prisma().find_many(take=10)

        # find the first 5 entrepise records ordered by the adresse field
        entrepises = await entrepise.prisma().find_many(
            take=5,
            order={
                'adresse': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.entrepiseWhereInput] = None,
        cursor: Optional[types.entrepiseWhereUniqueInput] = None,
        include: Optional[types.entrepiseInclude] = None,
        order: Optional[Union[types.entrepiseOrderByInput, List[types.entrepiseOrderByInput]]] = None,
        distinct: Optional[List[types.entrepiseScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single entrepise record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            entrepise filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned entrepise model
        order
            Order the returned entrepise records by any field
        distinct
            Filter entrepise records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.entrepise
            The first entrepise record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second entrepise record ordered by the mail field
        entrepise = await entrepise.prisma().find_first(
            skip=1,
            order={
                'mail': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.entrepiseUpdateInput,
        where: types.entrepiseWhereUniqueInput,
        include: Optional[types.entrepiseInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single entrepise record.

        Parameters
        ----------
        data
            entrepise record data specifying what to update
        where
            entrepise filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned entrepise model

        Returns
        -------
        prisma.models.entrepise
            The updated entrepise record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        entrepise = await entrepise.prisma().update(
            where={
                'id': 92728044,
            },
            data={
                # data to update the entrepise record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.entrepiseWhereUniqueInput,
        data: types.entrepiseUpsertInput,
        include: Optional[types.entrepiseInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            entrepise filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned entrepise model

        Returns
        -------
        prisma.models.entrepise
            The created or updated entrepise record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        entrepise = await entrepise.prisma().upsert(
            where={
                'id': 344858293,
            },
            data={
                'create': {
                    'id': 344858293,
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.entrepiseUpdateManyMutationInput,
        where: types.entrepiseWhereInput,
    ) -> int:
        """Update multiple entrepise records

        Parameters
        ----------
        data
            entrepise data to update the selected entrepise records to
        where
            Filter to select the entrepise records to update

        Returns
        -------
        int
            The total number of entrepise records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all entrepise records
        total = await entrepise.prisma().update_many(
            data={
                'tel': 'bbcbhebbda'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.entrepiseWhereInput] = None,
        cursor: Optional[types.entrepiseWhereUniqueInput] = None,
    ) -> int:
        """Count the number of entrepise records present in the database

        Parameters
        ----------
        select
            Select the entrepise fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            entrepise filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.entrepiseCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await entrepise.prisma().count()

        # results: prisma.types.entrepiseCountAggregateOutput
        results = await entrepise.prisma().count(
            select={
                '_all': True,
                'link': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.entrepiseCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.entrepiseWhereInput] = None,
        cursor: Optional[types.entrepiseWhereUniqueInput] = None,
    ) -> types.entrepiseCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.entrepiseCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.entrepiseWhereInput] = None,
        cursor: Optional[types.entrepiseWhereUniqueInput] = None,
    ) -> Union[int, types.entrepiseCountAggregateOutput]:
        """Count the number of entrepise records present in the database

        Parameters
        ----------
        select
            Select the entrepise fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            entrepise filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.entrepiseCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await entrepise.prisma().count()

        # results: prisma.types.entrepiseCountAggregateOutput
        results = await entrepise.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.entrepiseCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.entrepiseWhereInput] = None
    ) -> int:
        """Delete multiple entrepise records.

        Parameters
        ----------
        where
            Optional entrepise filter to find the records to be deleted

        Returns
        -------
        int
            The total number of entrepise records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all entrepise records
        total = await entrepise.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.entrepiseScalarFieldKeys'],
        *,
        where: Optional['types.entrepiseWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.entrepiseAvgAggregateInput'] = None,
        sum: Optional['types.entrepiseSumAggregateInput'] = None,
        min: Optional['types.entrepiseMinAggregateInput'] = None,
        max: Optional['types.entrepiseMaxAggregateInput'] = None,
        having: Optional['types.entrepiseScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.entrepiseCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.entrepiseScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.entrepiseScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.entrepiseGroupByOutput']:
        """Group entrepise records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar entrepise fields to group records by
        where
            entrepise filter to select records
        take
            Limit the maximum number of entrepise records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.entrepiseGroupByOutput]
            A list of dictionaries representing the entrepise record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group entrepise records by nom values
        # and count how many records are in each group
        results = await entrepise.prisma().group_by(
            ['nom'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class factureActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.facture]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await facture.prisma().query_raw(
            'SELECT * FROM facture WHERE id = ?',
            1495896251,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.facture
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await facture.prisma().query_first(
            'SELECT * FROM facture WHERE idDistr = ?',
            208521688,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.factureCreateInput,
        include: Optional[types.factureInclude] = None
    ) -> _PrismaModelT:
        """Create a new facture record.

        Parameters
        ----------
        data
            facture record data
        include
            Specifies which relations should be loaded on the returned facture model

        Returns
        -------
        prisma.models.facture
            The created facture record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a facture record from just the required fields
        facture = await facture.prisma().create(
            data={
                # data to create a facture record
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.factureCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple facture records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of facture record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await facture.prisma().create_many(
            data=[
                {
                    # data to create a facture record
                },
                {
                    # data to create a facture record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.factureWhereUniqueInput,
        include: Optional[types.factureInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single facture record.

        Parameters
        ----------
        where
            facture filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned facture model

        Returns
        -------
        prisma.models.facture
            The deleted facture record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        facture = await facture.prisma().delete(
            where={
                'id': 860811569,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.factureWhereUniqueInput,
        include: Optional[types.factureInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique facture record.

        Parameters
        ----------
        where
            facture filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned facture model

        Returns
        -------
        prisma.models.facture
            The found facture record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        facture = await facture.prisma().find_unique(
            where={
                'id': 1660932118,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.factureWhereInput] = None,
        cursor: Optional[types.factureWhereUniqueInput] = None,
        include: Optional[types.factureInclude] = None,
        order: Optional[Union[types.factureOrderByInput, List[types.factureOrderByInput]]] = None,
        distinct: Optional[List[types.factureScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple facture records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of facture records returned
        skip
            Ignore the first N results
        where
            facture filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned facture model
        order
            Order the returned facture records by any field
        distinct
            Filter facture records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.facture]
            The list of all facture records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 facture records
        factures = await facture.prisma().find_many(take=10)

        # find the first 5 facture records ordered by the idComm field
        factures = await facture.prisma().find_many(
            take=5,
            order={
                'idComm': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.factureWhereInput] = None,
        cursor: Optional[types.factureWhereUniqueInput] = None,
        include: Optional[types.factureInclude] = None,
        order: Optional[Union[types.factureOrderByInput, List[types.factureOrderByInput]]] = None,
        distinct: Optional[List[types.factureScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single facture record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            facture filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned facture model
        order
            Order the returned facture records by any field
        distinct
            Filter facture records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.facture
            The first facture record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second facture record ordered by the idInfoPaiment field
        facture = await facture.prisma().find_first(
            skip=1,
            order={
                'idInfoPaiment': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.factureUpdateInput,
        where: types.factureWhereUniqueInput,
        include: Optional[types.factureInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single facture record.

        Parameters
        ----------
        data
            facture record data specifying what to update
        where
            facture filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned facture model

        Returns
        -------
        prisma.models.facture
            The updated facture record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        facture = await facture.prisma().update(
            where={
                'id': 525761943,
            },
            data={
                # data to update the facture record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.factureWhereUniqueInput,
        data: types.factureUpsertInput,
        include: Optional[types.factureInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            facture filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned facture model

        Returns
        -------
        prisma.models.facture
            The created or updated facture record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        facture = await facture.prisma().upsert(
            where={
                'id': 736209796,
            },
            data={
                'create': {
                    'id': 736209796,
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.factureUpdateManyMutationInput,
        where: types.factureWhereInput,
    ) -> int:
        """Update multiple facture records

        Parameters
        ----------
        data
            facture data to update the selected facture records to
        where
            Filter to select the facture records to update

        Returns
        -------
        int
            The total number of facture records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all facture records
        total = await facture.prisma().update_many(
            data={
                'id': 493907821
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.factureWhereInput] = None,
        cursor: Optional[types.factureWhereUniqueInput] = None,
    ) -> int:
        """Count the number of facture records present in the database

        Parameters
        ----------
        select
            Select the facture fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            facture filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.factureCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await facture.prisma().count()

        # results: prisma.types.factureCountAggregateOutput
        results = await facture.prisma().count(
            select={
                '_all': True,
                'idDistr': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.factureCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.factureWhereInput] = None,
        cursor: Optional[types.factureWhereUniqueInput] = None,
    ) -> types.factureCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.factureCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.factureWhereInput] = None,
        cursor: Optional[types.factureWhereUniqueInput] = None,
    ) -> Union[int, types.factureCountAggregateOutput]:
        """Count the number of facture records present in the database

        Parameters
        ----------
        select
            Select the facture fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            facture filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.factureCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await facture.prisma().count()

        # results: prisma.types.factureCountAggregateOutput
        results = await facture.prisma().count(
            select={
                '_all': True,
                'idComm': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.factureCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.factureWhereInput] = None
    ) -> int:
        """Delete multiple facture records.

        Parameters
        ----------
        where
            Optional facture filter to find the records to be deleted

        Returns
        -------
        int
            The total number of facture records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all facture records
        total = await facture.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.factureScalarFieldKeys'],
        *,
        where: Optional['types.factureWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.factureAvgAggregateInput'] = None,
        sum: Optional['types.factureSumAggregateInput'] = None,
        min: Optional['types.factureMinAggregateInput'] = None,
        max: Optional['types.factureMaxAggregateInput'] = None,
        having: Optional['types.factureScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.factureCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.factureScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.factureScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.factureGroupByOutput']:
        """Group facture records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar facture fields to group records by
        where
            facture filter to select records
        take
            Limit the maximum number of facture records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.factureGroupByOutput]
            A list of dictionaries representing the facture record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group facture records by idInfoPaiment values
        # and count how many records are in each group
        results = await facture.prisma().group_by(
            ['idInfoPaiment'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class infopaimentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.infopaiment]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await infopaiment.prisma().query_raw(
            'SELECT * FROM infopaiment WHERE id = ?',
            639686562,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.infopaiment
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await infopaiment.prisma().query_first(
            'SELECT * FROM infopaiment WHERE mail = ?',
            'gfeaahdeh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.infopaimentCreateInput,
        include: Optional[types.infopaimentInclude] = None
    ) -> _PrismaModelT:
        """Create a new infopaiment record.

        Parameters
        ----------
        data
            infopaiment record data
        include
            Specifies which relations should be loaded on the returned infopaiment model

        Returns
        -------
        prisma.models.infopaiment
            The created infopaiment record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a infopaiment record from just the required fields
        infopaiment = await infopaiment.prisma().create(
            data={
                # data to create a infopaiment record
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.infopaimentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple infopaiment records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of infopaiment record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await infopaiment.prisma().create_many(
            data=[
                {
                    # data to create a infopaiment record
                },
                {
                    # data to create a infopaiment record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.infopaimentWhereUniqueInput,
        include: Optional[types.infopaimentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single infopaiment record.

        Parameters
        ----------
        where
            infopaiment filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned infopaiment model

        Returns
        -------
        prisma.models.infopaiment
            The deleted infopaiment record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        infopaiment = await infopaiment.prisma().delete(
            where={
                'id': 1905261552,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.infopaimentWhereUniqueInput,
        include: Optional[types.infopaimentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique infopaiment record.

        Parameters
        ----------
        where
            infopaiment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned infopaiment model

        Returns
        -------
        prisma.models.infopaiment
            The found infopaiment record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        infopaiment = await infopaiment.prisma().find_unique(
            where={
                'id': 78746985,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.infopaimentWhereInput] = None,
        cursor: Optional[types.infopaimentWhereUniqueInput] = None,
        include: Optional[types.infopaimentInclude] = None,
        order: Optional[Union[types.infopaimentOrderByInput, List[types.infopaimentOrderByInput]]] = None,
        distinct: Optional[List[types.infopaimentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple infopaiment records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of infopaiment records returned
        skip
            Ignore the first N results
        where
            infopaiment filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned infopaiment model
        order
            Order the returned infopaiment records by any field
        distinct
            Filter infopaiment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.infopaiment]
            The list of all infopaiment records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 infopaiment records
        infopaiments = await infopaiment.prisma().find_many(take=10)

        # find the first 5 infopaiment records ordered by the cartePaiment field
        infopaiments = await infopaiment.prisma().find_many(
            take=5,
            order={
                'cartePaiment': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.infopaimentWhereInput] = None,
        cursor: Optional[types.infopaimentWhereUniqueInput] = None,
        include: Optional[types.infopaimentInclude] = None,
        order: Optional[Union[types.infopaimentOrderByInput, List[types.infopaimentOrderByInput]]] = None,
        distinct: Optional[List[types.infopaimentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single infopaiment record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            infopaiment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned infopaiment model
        order
            Order the returned infopaiment records by any field
        distinct
            Filter infopaiment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.infopaiment
            The first infopaiment record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second infopaiment record ordered by the ccv field
        infopaiment = await infopaiment.prisma().find_first(
            skip=1,
            order={
                'ccv': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.infopaimentUpdateInput,
        where: types.infopaimentWhereUniqueInput,
        include: Optional[types.infopaimentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single infopaiment record.

        Parameters
        ----------
        data
            infopaiment record data specifying what to update
        where
            infopaiment filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned infopaiment model

        Returns
        -------
        prisma.models.infopaiment
            The updated infopaiment record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        infopaiment = await infopaiment.prisma().update(
            where={
                'id': 1398328302,
            },
            data={
                # data to update the infopaiment record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.infopaimentWhereUniqueInput,
        data: types.infopaimentUpsertInput,
        include: Optional[types.infopaimentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            infopaiment filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned infopaiment model

        Returns
        -------
        prisma.models.infopaiment
            The created or updated infopaiment record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        infopaiment = await infopaiment.prisma().upsert(
            where={
                'id': 856000655,
            },
            data={
                'create': {
                    'id': 856000655,
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.infopaimentUpdateManyMutationInput,
        where: types.infopaimentWhereInput,
    ) -> int:
        """Update multiple infopaiment records

        Parameters
        ----------
        data
            infopaiment data to update the selected infopaiment records to
        where
            Filter to select the infopaiment records to update

        Returns
        -------
        int
            The total number of infopaiment records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all infopaiment records
        total = await infopaiment.prisma().update_many(
            data={
                'expiryDate': 'befcddgjce'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.infopaimentWhereInput] = None,
        cursor: Optional[types.infopaimentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of infopaiment records present in the database

        Parameters
        ----------
        select
            Select the infopaiment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            infopaiment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.infopaimentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await infopaiment.prisma().count()

        # results: prisma.types.infopaimentCountAggregateOutput
        results = await infopaiment.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.infopaimentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.infopaimentWhereInput] = None,
        cursor: Optional[types.infopaimentWhereUniqueInput] = None,
    ) -> types.infopaimentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.infopaimentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.infopaimentWhereInput] = None,
        cursor: Optional[types.infopaimentWhereUniqueInput] = None,
    ) -> Union[int, types.infopaimentCountAggregateOutput]:
        """Count the number of infopaiment records present in the database

        Parameters
        ----------
        select
            Select the infopaiment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            infopaiment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.infopaimentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await infopaiment.prisma().count()

        # results: prisma.types.infopaimentCountAggregateOutput
        results = await infopaiment.prisma().count(
            select={
                '_all': True,
                'mail': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.infopaimentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.infopaimentWhereInput] = None
    ) -> int:
        """Delete multiple infopaiment records.

        Parameters
        ----------
        where
            Optional infopaiment filter to find the records to be deleted

        Returns
        -------
        int
            The total number of infopaiment records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all infopaiment records
        total = await infopaiment.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.infopaimentScalarFieldKeys'],
        *,
        where: Optional['types.infopaimentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.infopaimentAvgAggregateInput'] = None,
        sum: Optional['types.infopaimentSumAggregateInput'] = None,
        min: Optional['types.infopaimentMinAggregateInput'] = None,
        max: Optional['types.infopaimentMaxAggregateInput'] = None,
        having: Optional['types.infopaimentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.infopaimentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.infopaimentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.infopaimentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.infopaimentGroupByOutput']:
        """Group infopaiment records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar infopaiment fields to group records by
        where
            infopaiment filter to select records
        take
            Limit the maximum number of infopaiment records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.infopaimentGroupByOutput]
            A list of dictionaries representing the infopaiment record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group infopaiment records by cartePaiment values
        # and count how many records are in each group
        results = await infopaiment.prisma().group_by(
            ['cartePaiment'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ingredientActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ingredient]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ingredient.prisma().query_raw(
            'SELECT * FROM ingredient WHERE id = ?',
            1573199653,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ingredient
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ingredient.prisma().query_first(
            'SELECT * FROM ingredient WHERE type = ?',
            2013903098,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ingredientCreateInput,
        include: Optional[types.ingredientInclude] = None
    ) -> _PrismaModelT:
        """Create a new ingredient record.

        Parameters
        ----------
        data
            ingredient record data
        include
            Specifies which relations should be loaded on the returned ingredient model

        Returns
        -------
        prisma.models.ingredient
            The created ingredient record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ingredient record from just the required fields
        ingredient = await ingredient.prisma().create(
            data={
                # data to create a ingredient record
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ingredientCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ingredient records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ingredient record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ingredient.prisma().create_many(
            data=[
                {
                    # data to create a ingredient record
                },
                {
                    # data to create a ingredient record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ingredientWhereUniqueInput,
        include: Optional[types.ingredientInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ingredient record.

        Parameters
        ----------
        where
            ingredient filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ingredient model

        Returns
        -------
        prisma.models.ingredient
            The deleted ingredient record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        ingredient = await ingredient.prisma().delete(
            where={
                'id': 500965035,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.ingredientWhereUniqueInput,
        include: Optional[types.ingredientInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ingredient record.

        Parameters
        ----------
        where
            ingredient filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ingredient model

        Returns
        -------
        prisma.models.ingredient
            The found ingredient record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        ingredient = await ingredient.prisma().find_unique(
            where={
                'id': 1800624392,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ingredientWhereInput] = None,
        cursor: Optional[types.ingredientWhereUniqueInput] = None,
        include: Optional[types.ingredientInclude] = None,
        order: Optional[Union[types.ingredientOrderByInput, List[types.ingredientOrderByInput]]] = None,
        distinct: Optional[List[types.ingredientScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ingredient records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ingredient records returned
        skip
            Ignore the first N results
        where
            ingredient filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ingredient model
        order
            Order the returned ingredient records by any field
        distinct
            Filter ingredient records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ingredient]
            The list of all ingredient records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ingredient records
        ingredients = await ingredient.prisma().find_many(take=10)

        # find the first 5 ingredient records ordered by the description field
        ingredients = await ingredient.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ingredientWhereInput] = None,
        cursor: Optional[types.ingredientWhereUniqueInput] = None,
        include: Optional[types.ingredientInclude] = None,
        order: Optional[Union[types.ingredientOrderByInput, List[types.ingredientOrderByInput]]] = None,
        distinct: Optional[List[types.ingredientScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ingredient record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ingredient filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ingredient model
        order
            Order the returned ingredient records by any field
        distinct
            Filter ingredient records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ingredient
            The first ingredient record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ingredient record ordered by the prixUnit field
        ingredient = await ingredient.prisma().find_first(
            skip=1,
            order={
                'prixUnit': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.ingredientUpdateInput,
        where: types.ingredientWhereUniqueInput,
        include: Optional[types.ingredientInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ingredient record.

        Parameters
        ----------
        data
            ingredient record data specifying what to update
        where
            ingredient filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ingredient model

        Returns
        -------
        prisma.models.ingredient
            The updated ingredient record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        ingredient = await ingredient.prisma().update(
            where={
                'id': 2077067425,
            },
            data={
                # data to update the ingredient record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.ingredientWhereUniqueInput,
        data: types.ingredientUpsertInput,
        include: Optional[types.ingredientInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ingredient filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ingredient model

        Returns
        -------
        prisma.models.ingredient
            The created or updated ingredient record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        ingredient = await ingredient.prisma().upsert(
            where={
                'id': 1672112838,
            },
            data={
                'create': {
                    'id': 1672112838,
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.ingredientUpdateManyMutationInput,
        where: types.ingredientWhereInput,
    ) -> int:
        """Update multiple ingredient records

        Parameters
        ----------
        data
            ingredient data to update the selected ingredient records to
        where
            Filter to select the ingredient records to update

        Returns
        -------
        int
            The total number of ingredient records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ingredient records
        total = await ingredient.prisma().update_many(
            data={
                'id': 926677639
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ingredientWhereInput] = None,
        cursor: Optional[types.ingredientWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ingredient records present in the database

        Parameters
        ----------
        select
            Select the ingredient fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ingredient filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ingredientCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ingredient.prisma().count()

        # results: prisma.types.ingredientCountAggregateOutput
        results = await ingredient.prisma().count(
            select={
                '_all': True,
                'type': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ingredientCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ingredientWhereInput] = None,
        cursor: Optional[types.ingredientWhereUniqueInput] = None,
    ) -> types.ingredientCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ingredientCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ingredientWhereInput] = None,
        cursor: Optional[types.ingredientWhereUniqueInput] = None,
    ) -> Union[int, types.ingredientCountAggregateOutput]:
        """Count the number of ingredient records present in the database

        Parameters
        ----------
        select
            Select the ingredient fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ingredient filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ingredientCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ingredient.prisma().count()

        # results: prisma.types.ingredientCountAggregateOutput
        results = await ingredient.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ingredientCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ingredientWhereInput] = None
    ) -> int:
        """Delete multiple ingredient records.

        Parameters
        ----------
        where
            Optional ingredient filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ingredient records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ingredient records
        total = await ingredient.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ingredientScalarFieldKeys'],
        *,
        where: Optional['types.ingredientWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ingredientAvgAggregateInput'] = None,
        sum: Optional['types.ingredientSumAggregateInput'] = None,
        min: Optional['types.ingredientMinAggregateInput'] = None,
        max: Optional['types.ingredientMaxAggregateInput'] = None,
        having: Optional['types.ingredientScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ingredientCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ingredientScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ingredientScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ingredientGroupByOutput']:
        """Group ingredient records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ingredient fields to group records by
        where
            ingredient filter to select records
        take
            Limit the maximum number of ingredient records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ingredientGroupByOutput]
            A list of dictionaries representing the ingredient record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ingredient records by prixUnit values
        # and count how many records are in each group
        results = await ingredient.prisma().group_by(
            ['prixUnit'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class packActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.pack]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await pack.prisma().query_raw(
            'SELECT * FROM pack WHERE idDistr = ?',
            1447624116,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.pack
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await pack.prisma().query_first(
            'SELECT * FROM pack WHERE idEntre = ?',
            1738083805,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.packCreateInput,
        include: Optional[types.packInclude] = None
    ) -> _PrismaModelT:
        """Create a new pack record.

        Parameters
        ----------
        data
            pack record data
        include
            Specifies which relations should be loaded on the returned pack model

        Returns
        -------
        prisma.models.pack
            The created pack record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a pack record from just the required fields
        pack = await pack.prisma().create(
            data={
                # data to create a pack record
                'idDistr': 340946258,
                'idEntre': 601077795,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.packCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple pack records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of pack record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await pack.prisma().create_many(
            data=[
                {
                    # data to create a pack record
                    'idDistr': 290603296,
                    'idEntre': 1855826649,
                },
                {
                    # data to create a pack record
                    'idDistr': 1611009182,
                    'idEntre': 446673791,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.packWhereUniqueInput,
        include: Optional[types.packInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single pack record.

        Parameters
        ----------
        where
            pack filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned pack model

        Returns
        -------
        prisma.models.pack
            The deleted pack record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pack = await pack.prisma().delete(
            where={
                'idDistr': 300568396,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.packWhereUniqueInput,
        include: Optional[types.packInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique pack record.

        Parameters
        ----------
        where
            pack filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned pack model

        Returns
        -------
        prisma.models.pack
            The found pack record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pack = await pack.prisma().find_unique(
            where={
                'idDistr': 632626069,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.packWhereInput] = None,
        cursor: Optional[types.packWhereUniqueInput] = None,
        include: Optional[types.packInclude] = None,
        order: Optional[Union[types.packOrderByInput, List[types.packOrderByInput]]] = None,
        distinct: Optional[List[types.packScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple pack records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of pack records returned
        skip
            Ignore the first N results
        where
            pack filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned pack model
        order
            Order the returned pack records by any field
        distinct
            Filter pack records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.pack]
            The list of all pack records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 pack records
        packs = await pack.prisma().find_many(take=10)

        # find the first 5 pack records ordered by the codeverou field
        packs = await pack.prisma().find_many(
            take=5,
            order={
                'codeverou': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.packWhereInput] = None,
        cursor: Optional[types.packWhereUniqueInput] = None,
        include: Optional[types.packInclude] = None,
        order: Optional[Union[types.packOrderByInput, List[types.packOrderByInput]]] = None,
        distinct: Optional[List[types.packScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single pack record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            pack filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned pack model
        order
            Order the returned pack records by any field
        distinct
            Filter pack records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.pack
            The first pack record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second pack record ordered by the localisation field
        pack = await pack.prisma().find_first(
            skip=1,
            order={
                'localisation': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.packUpdateInput,
        where: types.packWhereUniqueInput,
        include: Optional[types.packInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single pack record.

        Parameters
        ----------
        data
            pack record data specifying what to update
        where
            pack filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned pack model

        Returns
        -------
        prisma.models.pack
            The updated pack record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        pack = await pack.prisma().update(
            where={
                'idDistr': 1724011690,
            },
            data={
                # data to update the pack record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.packWhereUniqueInput,
        data: types.packUpsertInput,
        include: Optional[types.packInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            pack filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned pack model

        Returns
        -------
        prisma.models.pack
            The created or updated pack record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pack = await pack.prisma().upsert(
            where={
                'idDistr': 470157467,
            },
            data={
                'create': {
                    'idDistr': 470157467,
                    'idEntre': 446673791,
                },
                'update': {
                    'idEntre': 446673791,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.packUpdateManyMutationInput,
        where: types.packWhereInput,
    ) -> int:
        """Update multiple pack records

        Parameters
        ----------
        data
            pack data to update the selected pack records to
        where
            Filter to select the pack records to update

        Returns
        -------
        int
            The total number of pack records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all pack records
        total = await pack.prisma().update_many(
            data={
                'state': 'bcajcajjbc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.packWhereInput] = None,
        cursor: Optional[types.packWhereUniqueInput] = None,
    ) -> int:
        """Count the number of pack records present in the database

        Parameters
        ----------
        select
            Select the pack fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            pack filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.packCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await pack.prisma().count()

        # results: prisma.types.packCountAggregateOutput
        results = await pack.prisma().count(
            select={
                '_all': True,
                'idDistr': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.packCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.packWhereInput] = None,
        cursor: Optional[types.packWhereUniqueInput] = None,
    ) -> types.packCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.packCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.packWhereInput] = None,
        cursor: Optional[types.packWhereUniqueInput] = None,
    ) -> Union[int, types.packCountAggregateOutput]:
        """Count the number of pack records present in the database

        Parameters
        ----------
        select
            Select the pack fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            pack filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.packCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await pack.prisma().count()

        # results: prisma.types.packCountAggregateOutput
        results = await pack.prisma().count(
            select={
                '_all': True,
                'idEntre': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.packCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.packWhereInput] = None
    ) -> int:
        """Delete multiple pack records.

        Parameters
        ----------
        where
            Optional pack filter to find the records to be deleted

        Returns
        -------
        int
            The total number of pack records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all pack records
        total = await pack.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.packScalarFieldKeys'],
        *,
        where: Optional['types.packWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.packAvgAggregateInput'] = None,
        sum: Optional['types.packSumAggregateInput'] = None,
        min: Optional['types.packMinAggregateInput'] = None,
        max: Optional['types.packMaxAggregateInput'] = None,
        having: Optional['types.packScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.packCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.packScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.packScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.packGroupByOutput']:
        """Group pack records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar pack fields to group records by
        where
            pack filter to select records
        take
            Limit the maximum number of pack records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.packGroupByOutput]
            A list of dictionaries representing the pack record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group pack records by codeverou values
        # and count how many records are in each group
        results = await pack.prisma().group_by(
            ['codeverou'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class publiciteActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.publicite]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await publicite.prisma().query_raw(
            'SELECT * FROM publicite WHERE id = ?',
            1536744465,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.publicite
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await publicite.prisma().query_first(
            'SELECT * FROM publicite WHERE url = ?',
            'ececbijji',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.publiciteCreateInput,
        include: Optional[types.publiciteInclude] = None
    ) -> _PrismaModelT:
        """Create a new publicite record.

        Parameters
        ----------
        data
            publicite record data
        include
            Specifies which relations should be loaded on the returned publicite model

        Returns
        -------
        prisma.models.publicite
            The created publicite record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a publicite record from just the required fields
        publicite = await publicite.prisma().create(
            data={
                # data to create a publicite record
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.publiciteCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple publicite records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of publicite record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await publicite.prisma().create_many(
            data=[
                {
                    # data to create a publicite record
                },
                {
                    # data to create a publicite record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.publiciteWhereUniqueInput,
        include: Optional[types.publiciteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single publicite record.

        Parameters
        ----------
        where
            publicite filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned publicite model

        Returns
        -------
        prisma.models.publicite
            The deleted publicite record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        publicite = await publicite.prisma().delete(
            where={
                'id': 2125632375,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.publiciteWhereUniqueInput,
        include: Optional[types.publiciteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique publicite record.

        Parameters
        ----------
        where
            publicite filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned publicite model

        Returns
        -------
        prisma.models.publicite
            The found publicite record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        publicite = await publicite.prisma().find_unique(
            where={
                'id': 536951780,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.publiciteWhereInput] = None,
        cursor: Optional[types.publiciteWhereUniqueInput] = None,
        include: Optional[types.publiciteInclude] = None,
        order: Optional[Union[types.publiciteOrderByInput, List[types.publiciteOrderByInput]]] = None,
        distinct: Optional[List[types.publiciteScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple publicite records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of publicite records returned
        skip
            Ignore the first N results
        where
            publicite filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned publicite model
        order
            Order the returned publicite records by any field
        distinct
            Filter publicite records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.publicite]
            The list of all publicite records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 publicite records
        publicites = await publicite.prisma().find_many(take=10)

        # find the first 5 publicite records ordered by the idCategorie field
        publicites = await publicite.prisma().find_many(
            take=5,
            order={
                'idCategorie': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.publiciteWhereInput] = None,
        cursor: Optional[types.publiciteWhereUniqueInput] = None,
        include: Optional[types.publiciteInclude] = None,
        order: Optional[Union[types.publiciteOrderByInput, List[types.publiciteOrderByInput]]] = None,
        distinct: Optional[List[types.publiciteScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single publicite record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            publicite filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned publicite model
        order
            Order the returned publicite records by any field
        distinct
            Filter publicite records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.publicite
            The first publicite record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second publicite record ordered by the idCategRecette field
        publicite = await publicite.prisma().find_first(
            skip=1,
            order={
                'idCategRecette': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.publiciteUpdateInput,
        where: types.publiciteWhereUniqueInput,
        include: Optional[types.publiciteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single publicite record.

        Parameters
        ----------
        data
            publicite record data specifying what to update
        where
            publicite filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned publicite model

        Returns
        -------
        prisma.models.publicite
            The updated publicite record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        publicite = await publicite.prisma().update(
            where={
                'id': 924723277,
            },
            data={
                # data to update the publicite record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.publiciteWhereUniqueInput,
        data: types.publiciteUpsertInput,
        include: Optional[types.publiciteInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            publicite filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned publicite model

        Returns
        -------
        prisma.models.publicite
            The created or updated publicite record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        publicite = await publicite.prisma().upsert(
            where={
                'id': 1621937922,
            },
            data={
                'create': {
                    'id': 1621937922,
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.publiciteUpdateManyMutationInput,
        where: types.publiciteWhereInput,
    ) -> int:
        """Update multiple publicite records

        Parameters
        ----------
        data
            publicite data to update the selected publicite records to
        where
            Filter to select the publicite records to update

        Returns
        -------
        int
            The total number of publicite records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all publicite records
        total = await publicite.prisma().update_many(
            data={
                'idAnnonceur': 1848832019
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.publiciteWhereInput] = None,
        cursor: Optional[types.publiciteWhereUniqueInput] = None,
    ) -> int:
        """Count the number of publicite records present in the database

        Parameters
        ----------
        select
            Select the publicite fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            publicite filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.publiciteCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await publicite.prisma().count()

        # results: prisma.types.publiciteCountAggregateOutput
        results = await publicite.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.publiciteCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.publiciteWhereInput] = None,
        cursor: Optional[types.publiciteWhereUniqueInput] = None,
    ) -> types.publiciteCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.publiciteCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.publiciteWhereInput] = None,
        cursor: Optional[types.publiciteWhereUniqueInput] = None,
    ) -> Union[int, types.publiciteCountAggregateOutput]:
        """Count the number of publicite records present in the database

        Parameters
        ----------
        select
            Select the publicite fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            publicite filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.publiciteCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await publicite.prisma().count()

        # results: prisma.types.publiciteCountAggregateOutput
        results = await publicite.prisma().count(
            select={
                '_all': True,
                'url': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.publiciteCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.publiciteWhereInput] = None
    ) -> int:
        """Delete multiple publicite records.

        Parameters
        ----------
        where
            Optional publicite filter to find the records to be deleted

        Returns
        -------
        int
            The total number of publicite records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all publicite records
        total = await publicite.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.publiciteScalarFieldKeys'],
        *,
        where: Optional['types.publiciteWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.publiciteAvgAggregateInput'] = None,
        sum: Optional['types.publiciteSumAggregateInput'] = None,
        min: Optional['types.publiciteMinAggregateInput'] = None,
        max: Optional['types.publiciteMaxAggregateInput'] = None,
        having: Optional['types.publiciteScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.publiciteCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.publiciteScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.publiciteScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.publiciteGroupByOutput']:
        """Group publicite records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar publicite fields to group records by
        where
            publicite filter to select records
        take
            Limit the maximum number of publicite records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.publiciteGroupByOutput]
            A list of dictionaries representing the publicite record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group publicite records by idCategorie values
        # and count how many records are in each group
        results = await publicite.prisma().group_by(
            ['idCategorie'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class recetteActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.recette]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await recette.prisma().query_raw(
            'SELECT * FROM recette WHERE id = ?',
            1921528400,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.recette
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await recette.prisma().query_first(
            'SELECT * FROM recette WHERE idCategRecette = ?',
            2100427849,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.recetteCreateInput,
        include: Optional[types.recetteInclude] = None
    ) -> _PrismaModelT:
        """Create a new recette record.

        Parameters
        ----------
        data
            recette record data
        include
            Specifies which relations should be loaded on the returned recette model

        Returns
        -------
        prisma.models.recette
            The created recette record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a recette record from just the required fields
        recette = await recette.prisma().create(
            data={
                # data to create a recette record
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.recetteCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple recette records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of recette record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await recette.prisma().create_many(
            data=[
                {
                    # data to create a recette record
                },
                {
                    # data to create a recette record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.recetteWhereUniqueInput,
        include: Optional[types.recetteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single recette record.

        Parameters
        ----------
        where
            recette filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned recette model

        Returns
        -------
        prisma.models.recette
            The deleted recette record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        recette = await recette.prisma().delete(
            where={
                'id': 849140046,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.recetteWhereUniqueInput,
        include: Optional[types.recetteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique recette record.

        Parameters
        ----------
        where
            recette filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned recette model

        Returns
        -------
        prisma.models.recette
            The found recette record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        recette = await recette.prisma().find_unique(
            where={
                'id': 928152175,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.recetteWhereInput] = None,
        cursor: Optional[types.recetteWhereUniqueInput] = None,
        include: Optional[types.recetteInclude] = None,
        order: Optional[Union[types.recetteOrderByInput, List[types.recetteOrderByInput]]] = None,
        distinct: Optional[List[types.recetteScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple recette records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of recette records returned
        skip
            Ignore the first N results
        where
            recette filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned recette model
        order
            Order the returned recette records by any field
        distinct
            Filter recette records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.recette]
            The list of all recette records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 recette records
        recettes = await recette.prisma().find_many(take=10)

        # find the first 5 recette records ordered by the name field
        recettes = await recette.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.recetteWhereInput] = None,
        cursor: Optional[types.recetteWhereUniqueInput] = None,
        include: Optional[types.recetteInclude] = None,
        order: Optional[Union[types.recetteOrderByInput, List[types.recetteOrderByInput]]] = None,
        distinct: Optional[List[types.recetteScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single recette record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            recette filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned recette model
        order
            Order the returned recette records by any field
        distinct
            Filter recette records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.recette
            The first recette record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second recette record ordered by the description field
        recette = await recette.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.recetteUpdateInput,
        where: types.recetteWhereUniqueInput,
        include: Optional[types.recetteInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single recette record.

        Parameters
        ----------
        data
            recette record data specifying what to update
        where
            recette filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned recette model

        Returns
        -------
        prisma.models.recette
            The updated recette record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        recette = await recette.prisma().update(
            where={
                'id': 273032060,
            },
            data={
                # data to update the recette record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.recetteWhereUniqueInput,
        data: types.recetteUpsertInput,
        include: Optional[types.recetteInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            recette filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned recette model

        Returns
        -------
        prisma.models.recette
            The created or updated recette record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        recette = await recette.prisma().upsert(
            where={
                'id': 982848517,
            },
            data={
                'create': {
                    'id': 982848517,
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.recetteUpdateManyMutationInput,
        where: types.recetteWhereInput,
    ) -> int:
        """Update multiple recette records

        Parameters
        ----------
        data
            recette data to update the selected recette records to
        where
            Filter to select the recette records to update

        Returns
        -------
        int
            The total number of recette records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all recette records
        total = await recette.prisma().update_many(
            data={
                'price': Decimal('510737498.211748')
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.recetteWhereInput] = None,
        cursor: Optional[types.recetteWhereUniqueInput] = None,
    ) -> int:
        """Count the number of recette records present in the database

        Parameters
        ----------
        select
            Select the recette fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            recette filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.recetteCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await recette.prisma().count()

        # results: prisma.types.recetteCountAggregateOutput
        results = await recette.prisma().count(
            select={
                '_all': True,
                'imageLink': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.recetteCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.recetteWhereInput] = None,
        cursor: Optional[types.recetteWhereUniqueInput] = None,
    ) -> types.recetteCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.recetteCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.recetteWhereInput] = None,
        cursor: Optional[types.recetteWhereUniqueInput] = None,
    ) -> Union[int, types.recetteCountAggregateOutput]:
        """Count the number of recette records present in the database

        Parameters
        ----------
        select
            Select the recette fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            recette filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.recetteCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await recette.prisma().count()

        # results: prisma.types.recetteCountAggregateOutput
        results = await recette.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.recetteCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.recetteWhereInput] = None
    ) -> int:
        """Delete multiple recette records.

        Parameters
        ----------
        where
            Optional recette filter to find the records to be deleted

        Returns
        -------
        int
            The total number of recette records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all recette records
        total = await recette.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.recetteScalarFieldKeys'],
        *,
        where: Optional['types.recetteWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.recetteAvgAggregateInput'] = None,
        sum: Optional['types.recetteSumAggregateInput'] = None,
        min: Optional['types.recetteMinAggregateInput'] = None,
        max: Optional['types.recetteMaxAggregateInput'] = None,
        having: Optional['types.recetteScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.recetteCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.recetteScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.recetteScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.recetteGroupByOutput']:
        """Group recette records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar recette fields to group records by
        where
            recette filter to select records
        take
            Limit the maximum number of recette records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.recetteGroupByOutput]
            A list of dictionaries representing the recette record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group recette records by idCategRecette values
        # and count how many records are in each group
        results = await recette.prisma().group_by(
            ['idCategRecette'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class recetteingrActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.recetteingr]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await recetteingr.prisma().query_raw(
            'SELECT * FROM recetteingr WHERE idRecette = ?',
            1401944936,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.recetteingr
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await recetteingr.prisma().query_first(
            'SELECT * FROM recetteingr WHERE idIngredient = ?',
            1297607553,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.recetteingrCreateInput,
        include: Optional[types.recetteingrInclude] = None
    ) -> _PrismaModelT:
        """Create a new recetteingr record.

        Parameters
        ----------
        data
            recetteingr record data
        include
            Specifies which relations should be loaded on the returned recetteingr model

        Returns
        -------
        prisma.models.recetteingr
            The created recetteingr record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a recetteingr record from just the required fields
        recetteingr = await recetteingr.prisma().create(
            data={
                # data to create a recetteingr record
                'idRecette': 519488550,
                'idIngredient': 976832615,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.recetteingrCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple recetteingr records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of recetteingr record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await recetteingr.prisma().create_many(
            data=[
                {
                    # data to create a recetteingr record
                    'idRecette': 1696425492,
                    'idIngredient': 169262781,
                },
                {
                    # data to create a recetteingr record
                    'idRecette': 1023081650,
                    'idIngredient': 327681027,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.recetteingrWhereUniqueInput,
        include: Optional[types.recetteingrInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single recetteingr record.

        Parameters
        ----------
        where
            recetteingr filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned recetteingr model

        Returns
        -------
        prisma.models.recetteingr
            The deleted recetteingr record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        recetteingr = await recetteingr.prisma().delete(
            where={
                # recetteingr where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.recetteingrWhereUniqueInput,
        include: Optional[types.recetteingrInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique recetteingr record.

        Parameters
        ----------
        where
            recetteingr filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned recetteingr model

        Returns
        -------
        prisma.models.recetteingr
            The found recetteingr record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        recetteingr = await recetteingr.prisma().find_unique(
            where={
                # recetteingr where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.recetteingrWhereInput] = None,
        cursor: Optional[types.recetteingrWhereUniqueInput] = None,
        include: Optional[types.recetteingrInclude] = None,
        order: Optional[Union[types.recetteingrOrderByInput, List[types.recetteingrOrderByInput]]] = None,
        distinct: Optional[List[types.recetteingrScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple recetteingr records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of recetteingr records returned
        skip
            Ignore the first N results
        where
            recetteingr filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned recetteingr model
        order
            Order the returned recetteingr records by any field
        distinct
            Filter recetteingr records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.recetteingr]
            The list of all recetteingr records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 recetteingr records
        recetteingrs = await recetteingr.prisma().find_many(take=10)

        # find the first 5 recetteingr records ordered by the quantity field
        recetteingrs = await recetteingr.prisma().find_many(
            take=5,
            order={
                'quantity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.recetteingrWhereInput] = None,
        cursor: Optional[types.recetteingrWhereUniqueInput] = None,
        include: Optional[types.recetteingrInclude] = None,
        order: Optional[Union[types.recetteingrOrderByInput, List[types.recetteingrOrderByInput]]] = None,
        distinct: Optional[List[types.recetteingrScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single recetteingr record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            recetteingr filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned recetteingr model
        order
            Order the returned recetteingr records by any field
        distinct
            Filter recetteingr records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.recetteingr
            The first recetteingr record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second recetteingr record ordered by the idRecette field
        recetteingr = await recetteingr.prisma().find_first(
            skip=1,
            order={
                'idRecette': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.recetteingrUpdateInput,
        where: types.recetteingrWhereUniqueInput,
        include: Optional[types.recetteingrInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single recetteingr record.

        Parameters
        ----------
        data
            recetteingr record data specifying what to update
        where
            recetteingr filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned recetteingr model

        Returns
        -------
        prisma.models.recetteingr
            The updated recetteingr record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        recetteingr = await recetteingr.prisma().update(
            where={
                # recetteingr where unique filter

            },
            data={
                # data to update the recetteingr record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.recetteingrWhereUniqueInput,
        data: types.recetteingrUpsertInput,
        include: Optional[types.recetteingrInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            recetteingr filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned recetteingr model

        Returns
        -------
        prisma.models.recetteingr
            The created or updated recetteingr record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        recetteingr = await recetteingr.prisma().upsert(
            where={
                # recetteingr where unique filter
            },
            data={
                'create': {
                    # recetteingr data to be set if the record does not exist
                },
                'update': {
                    # recetteingr data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.recetteingrUpdateManyMutationInput,
        where: types.recetteingrWhereInput,
    ) -> int:
        """Update multiple recetteingr records

        Parameters
        ----------
        data
            recetteingr data to update the selected recetteingr records to
        where
            Filter to select the recetteingr records to update

        Returns
        -------
        int
            The total number of recetteingr records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all recetteingr records
        total = await recetteingr.prisma().update_many(
            data={
                'idIngredient': 527748992
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.recetteingrWhereInput] = None,
        cursor: Optional[types.recetteingrWhereUniqueInput] = None,
    ) -> int:
        """Count the number of recetteingr records present in the database

        Parameters
        ----------
        select
            Select the recetteingr fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            recetteingr filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.recetteingrCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await recetteingr.prisma().count()

        # results: prisma.types.recetteingrCountAggregateOutput
        results = await recetteingr.prisma().count(
            select={
                '_all': True,
                'quantity': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.recetteingrCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.recetteingrWhereInput] = None,
        cursor: Optional[types.recetteingrWhereUniqueInput] = None,
    ) -> types.recetteingrCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.recetteingrCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.recetteingrWhereInput] = None,
        cursor: Optional[types.recetteingrWhereUniqueInput] = None,
    ) -> Union[int, types.recetteingrCountAggregateOutput]:
        """Count the number of recetteingr records present in the database

        Parameters
        ----------
        select
            Select the recetteingr fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            recetteingr filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.recetteingrCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await recetteingr.prisma().count()

        # results: prisma.types.recetteingrCountAggregateOutput
        results = await recetteingr.prisma().count(
            select={
                '_all': True,
                'idRecette': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.recetteingrCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.recetteingrWhereInput] = None
    ) -> int:
        """Delete multiple recetteingr records.

        Parameters
        ----------
        where
            Optional recetteingr filter to find the records to be deleted

        Returns
        -------
        int
            The total number of recetteingr records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all recetteingr records
        total = await recetteingr.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.recetteingrScalarFieldKeys'],
        *,
        where: Optional['types.recetteingrWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.recetteingrAvgAggregateInput'] = None,
        sum: Optional['types.recetteingrSumAggregateInput'] = None,
        min: Optional['types.recetteingrMinAggregateInput'] = None,
        max: Optional['types.recetteingrMaxAggregateInput'] = None,
        having: Optional['types.recetteingrScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.recetteingrCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.recetteingrScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.recetteingrScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.recetteingrGroupByOutput']:
        """Group recetteingr records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar recetteingr fields to group records by
        where
            recetteingr filter to select records
        take
            Limit the maximum number of recetteingr records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.recetteingrGroupByOutput]
            A list of dictionaries representing the recetteingr record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group recetteingr records by idIngredient values
        # and count how many records are in each group
        results = await recetteingr.prisma().group_by(
            ['idIngredient'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class reclamationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.reclamation]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await reclamation.prisma().query_raw(
            'SELECT * FROM reclamation WHERE id = ?',
            2029357497,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.reclamation
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await reclamation.prisma().query_first(
            'SELECT * FROM reclamation WHERE idFacture = ?',
            1318597118,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.reclamationCreateInput,
        include: Optional[types.reclamationInclude] = None
    ) -> _PrismaModelT:
        """Create a new reclamation record.

        Parameters
        ----------
        data
            reclamation record data
        include
            Specifies which relations should be loaded on the returned reclamation model

        Returns
        -------
        prisma.models.reclamation
            The created reclamation record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a reclamation record from just the required fields
        reclamation = await reclamation.prisma().create(
            data={
                # data to create a reclamation record
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.reclamationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple reclamation records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of reclamation record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await reclamation.prisma().create_many(
            data=[
                {
                    # data to create a reclamation record
                },
                {
                    # data to create a reclamation record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.reclamationWhereUniqueInput,
        include: Optional[types.reclamationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single reclamation record.

        Parameters
        ----------
        where
            reclamation filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned reclamation model

        Returns
        -------
        prisma.models.reclamation
            The deleted reclamation record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        reclamation = await reclamation.prisma().delete(
            where={
                'id': 2122112351,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.reclamationWhereUniqueInput,
        include: Optional[types.reclamationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique reclamation record.

        Parameters
        ----------
        where
            reclamation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned reclamation model

        Returns
        -------
        prisma.models.reclamation
            The found reclamation record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        reclamation = await reclamation.prisma().find_unique(
            where={
                'id': 1024943020,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.reclamationWhereInput] = None,
        cursor: Optional[types.reclamationWhereUniqueInput] = None,
        include: Optional[types.reclamationInclude] = None,
        order: Optional[Union[types.reclamationOrderByInput, List[types.reclamationOrderByInput]]] = None,
        distinct: Optional[List[types.reclamationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple reclamation records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of reclamation records returned
        skip
            Ignore the first N results
        where
            reclamation filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned reclamation model
        order
            Order the returned reclamation records by any field
        distinct
            Filter reclamation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.reclamation]
            The list of all reclamation records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 reclamation records
        reclamations = await reclamation.prisma().find_many(take=10)

        # find the first 5 reclamation records ordered by the message field
        reclamations = await reclamation.prisma().find_many(
            take=5,
            order={
                'message': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.reclamationWhereInput] = None,
        cursor: Optional[types.reclamationWhereUniqueInput] = None,
        include: Optional[types.reclamationInclude] = None,
        order: Optional[Union[types.reclamationOrderByInput, List[types.reclamationOrderByInput]]] = None,
        distinct: Optional[List[types.reclamationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single reclamation record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            reclamation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned reclamation model
        order
            Order the returned reclamation records by any field
        distinct
            Filter reclamation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.reclamation
            The first reclamation record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second reclamation record ordered by the isDone field
        reclamation = await reclamation.prisma().find_first(
            skip=1,
            order={
                'isDone': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.reclamationUpdateInput,
        where: types.reclamationWhereUniqueInput,
        include: Optional[types.reclamationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single reclamation record.

        Parameters
        ----------
        data
            reclamation record data specifying what to update
        where
            reclamation filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned reclamation model

        Returns
        -------
        prisma.models.reclamation
            The updated reclamation record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        reclamation = await reclamation.prisma().update(
            where={
                'id': 1717307509,
            },
            data={
                # data to update the reclamation record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.reclamationWhereUniqueInput,
        data: types.reclamationUpsertInput,
        include: Optional[types.reclamationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            reclamation filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned reclamation model

        Returns
        -------
        prisma.models.reclamation
            The created or updated reclamation record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        reclamation = await reclamation.prisma().upsert(
            where={
                'id': 1598124042,
            },
            data={
                'create': {
                    'id': 1598124042,
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.reclamationUpdateManyMutationInput,
        where: types.reclamationWhereInput,
    ) -> int:
        """Update multiple reclamation records

        Parameters
        ----------
        data
            reclamation data to update the selected reclamation records to
        where
            Filter to select the reclamation records to update

        Returns
        -------
        int
            The total number of reclamation records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all reclamation records
        total = await reclamation.prisma().update_many(
            data={
                'idCategoryClaim': 817623163
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.reclamationWhereInput] = None,
        cursor: Optional[types.reclamationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of reclamation records present in the database

        Parameters
        ----------
        select
            Select the reclamation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            reclamation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.reclamationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await reclamation.prisma().count()

        # results: prisma.types.reclamationCountAggregateOutput
        results = await reclamation.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.reclamationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.reclamationWhereInput] = None,
        cursor: Optional[types.reclamationWhereUniqueInput] = None,
    ) -> types.reclamationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.reclamationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.reclamationWhereInput] = None,
        cursor: Optional[types.reclamationWhereUniqueInput] = None,
    ) -> Union[int, types.reclamationCountAggregateOutput]:
        """Count the number of reclamation records present in the database

        Parameters
        ----------
        select
            Select the reclamation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            reclamation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.reclamationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await reclamation.prisma().count()

        # results: prisma.types.reclamationCountAggregateOutput
        results = await reclamation.prisma().count(
            select={
                '_all': True,
                'idFacture': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.reclamationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.reclamationWhereInput] = None
    ) -> int:
        """Delete multiple reclamation records.

        Parameters
        ----------
        where
            Optional reclamation filter to find the records to be deleted

        Returns
        -------
        int
            The total number of reclamation records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all reclamation records
        total = await reclamation.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.reclamationScalarFieldKeys'],
        *,
        where: Optional['types.reclamationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.reclamationAvgAggregateInput'] = None,
        sum: Optional['types.reclamationSumAggregateInput'] = None,
        min: Optional['types.reclamationMinAggregateInput'] = None,
        max: Optional['types.reclamationMaxAggregateInput'] = None,
        having: Optional['types.reclamationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.reclamationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.reclamationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.reclamationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.reclamationGroupByOutput']:
        """Group reclamation records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar reclamation fields to group records by
        where
            reclamation filter to select records
        take
            Limit the maximum number of reclamation records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.reclamationGroupByOutput]
            A list of dictionaries representing the reclamation record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group reclamation records by message values
        # and count how many records are in each group
        results = await reclamation.prisma().group_by(
            ['message'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class roleActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.role]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await role.prisma().query_raw(
            'SELECT * FROM role WHERE id = ?',
            1030557336,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.role
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await role.prisma().query_first(
            'SELECT * FROM role WHERE description = ?',
            'bbdbfcfihd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.roleCreateInput,
        include: Optional[types.roleInclude] = None
    ) -> _PrismaModelT:
        """Create a new role record.

        Parameters
        ----------
        data
            role record data
        include
            Specifies which relations should be loaded on the returned role model

        Returns
        -------
        prisma.models.role
            The created role record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a role record from just the required fields
        role = await role.prisma().create(
            data={
                # data to create a role record
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.roleCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple role records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of role record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await role.prisma().create_many(
            data=[
                {
                    # data to create a role record
                },
                {
                    # data to create a role record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.roleWhereUniqueInput,
        include: Optional[types.roleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single role record.

        Parameters
        ----------
        where
            role filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned role model

        Returns
        -------
        prisma.models.role
            The deleted role record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        role = await role.prisma().delete(
            where={
                'id': 210666198,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.roleWhereUniqueInput,
        include: Optional[types.roleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique role record.

        Parameters
        ----------
        where
            role filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned role model

        Returns
        -------
        prisma.models.role
            The found role record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        role = await role.prisma().find_unique(
            where={
                'id': 1276057943,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.roleWhereInput] = None,
        cursor: Optional[types.roleWhereUniqueInput] = None,
        include: Optional[types.roleInclude] = None,
        order: Optional[Union[types.roleOrderByInput, List[types.roleOrderByInput]]] = None,
        distinct: Optional[List[types.roleScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple role records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of role records returned
        skip
            Ignore the first N results
        where
            role filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned role model
        order
            Order the returned role records by any field
        distinct
            Filter role records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.role]
            The list of all role records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 role records
        roles = await role.prisma().find_many(take=10)

        # find the first 5 role records ordered by the id field
        roles = await role.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.roleWhereInput] = None,
        cursor: Optional[types.roleWhereUniqueInput] = None,
        include: Optional[types.roleInclude] = None,
        order: Optional[Union[types.roleOrderByInput, List[types.roleOrderByInput]]] = None,
        distinct: Optional[List[types.roleScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single role record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            role filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned role model
        order
            Order the returned role records by any field
        distinct
            Filter role records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.role
            The first role record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second role record ordered by the description field
        role = await role.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.roleUpdateInput,
        where: types.roleWhereUniqueInput,
        include: Optional[types.roleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single role record.

        Parameters
        ----------
        data
            role record data specifying what to update
        where
            role filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned role model

        Returns
        -------
        prisma.models.role
            The updated role record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        role = await role.prisma().update(
            where={
                'id': 745569348,
            },
            data={
                # data to update the role record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.roleWhereUniqueInput,
        data: types.roleUpsertInput,
        include: Optional[types.roleInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            role filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned role model

        Returns
        -------
        prisma.models.role
            The created or updated role record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        role = await role.prisma().upsert(
            where={
                'id': 307876141,
            },
            data={
                'create': {
                    'id': 307876141,
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.roleUpdateManyMutationInput,
        where: types.roleWhereInput,
    ) -> int:
        """Update multiple role records

        Parameters
        ----------
        data
            role data to update the selected role records to
        where
            Filter to select the role records to update

        Returns
        -------
        int
            The total number of role records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all role records
        total = await role.prisma().update_many(
            data={
                'id': 1674049122
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.roleWhereInput] = None,
        cursor: Optional[types.roleWhereUniqueInput] = None,
    ) -> int:
        """Count the number of role records present in the database

        Parameters
        ----------
        select
            Select the role fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            role filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.roleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await role.prisma().count()

        # results: prisma.types.roleCountAggregateOutput
        results = await role.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.roleCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.roleWhereInput] = None,
        cursor: Optional[types.roleWhereUniqueInput] = None,
    ) -> types.roleCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.roleCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.roleWhereInput] = None,
        cursor: Optional[types.roleWhereUniqueInput] = None,
    ) -> Union[int, types.roleCountAggregateOutput]:
        """Count the number of role records present in the database

        Parameters
        ----------
        select
            Select the role fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            role filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.roleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await role.prisma().count()

        # results: prisma.types.roleCountAggregateOutput
        results = await role.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.roleCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.roleWhereInput] = None
    ) -> int:
        """Delete multiple role records.

        Parameters
        ----------
        where
            Optional role filter to find the records to be deleted

        Returns
        -------
        int
            The total number of role records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all role records
        total = await role.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.roleScalarFieldKeys'],
        *,
        where: Optional['types.roleWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.roleAvgAggregateInput'] = None,
        sum: Optional['types.roleSumAggregateInput'] = None,
        min: Optional['types.roleMinAggregateInput'] = None,
        max: Optional['types.roleMaxAggregateInput'] = None,
        having: Optional['types.roleScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.roleCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.roleScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.roleScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.roleGroupByOutput']:
        """Group role records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar role fields to group records by
        where
            role filter to select records
        take
            Limit the maximum number of role records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.roleGroupByOutput]
            A list of dictionaries representing the role record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group role records by description values
        # and count how many records are in each group
        results = await role.prisma().group_by(
            ['description'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class sensorsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.sensors]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await sensors.prisma().query_raw(
            'SELECT * FROM sensors WHERE id = ?',
            1526854643,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.sensors
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await sensors.prisma().query_first(
            'SELECT * FROM sensors WHERE idDistr = ?',
            958077104,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.sensorsCreateInput,
        include: Optional[types.sensorsInclude] = None
    ) -> _PrismaModelT:
        """Create a new sensors record.

        Parameters
        ----------
        data
            sensors record data
        include
            Specifies which relations should be loaded on the returned sensors model

        Returns
        -------
        prisma.models.sensors
            The created sensors record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a sensors record from just the required fields
        sensors = await sensors.prisma().create(
            data={
                # data to create a sensors record
                'idDistr': 1513050921,
                'idSensor': 204674734,
                'value': 'caghgfbggd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.sensorsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple sensors records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of sensors record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await sensors.prisma().create_many(
            data=[
                {
                    # data to create a sensors record
                    'idDistr': 1183911900,
                    'idSensor': 1589704933,
                    'value': 'bcedehfiji',
                },
                {
                    # data to create a sensors record
                    'idDistr': 1369828971,
                    'idSensor': 1678593480,
                    'value': 'eadfcbbcb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.sensorsWhereUniqueInput,
        include: Optional[types.sensorsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single sensors record.

        Parameters
        ----------
        where
            sensors filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned sensors model

        Returns
        -------
        prisma.models.sensors
            The deleted sensors record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        sensors = await sensors.prisma().delete(
            where={
                'id': 648760710,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.sensorsWhereUniqueInput,
        include: Optional[types.sensorsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique sensors record.

        Parameters
        ----------
        where
            sensors filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned sensors model

        Returns
        -------
        prisma.models.sensors
            The found sensors record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        sensors = await sensors.prisma().find_unique(
            where={
                'id': 607323719,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.sensorsWhereInput] = None,
        cursor: Optional[types.sensorsWhereUniqueInput] = None,
        include: Optional[types.sensorsInclude] = None,
        order: Optional[Union[types.sensorsOrderByInput, List[types.sensorsOrderByInput]]] = None,
        distinct: Optional[List[types.sensorsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple sensors records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of sensors records returned
        skip
            Ignore the first N results
        where
            sensors filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned sensors model
        order
            Order the returned sensors records by any field
        distinct
            Filter sensors records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.sensors]
            The list of all sensors records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 sensors records
        sensors = await sensors.prisma().find_many(take=10)

        # find the first 5 sensors records ordered by the idSensor field
        sensors = await sensors.prisma().find_many(
            take=5,
            order={
                'idSensor': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.sensorsWhereInput] = None,
        cursor: Optional[types.sensorsWhereUniqueInput] = None,
        include: Optional[types.sensorsInclude] = None,
        order: Optional[Union[types.sensorsOrderByInput, List[types.sensorsOrderByInput]]] = None,
        distinct: Optional[List[types.sensorsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single sensors record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            sensors filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned sensors model
        order
            Order the returned sensors records by any field
        distinct
            Filter sensors records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.sensors
            The first sensors record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second sensors record ordered by the value field
        sensors = await sensors.prisma().find_first(
            skip=1,
            order={
                'value': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.sensorsUpdateInput,
        where: types.sensorsWhereUniqueInput,
        include: Optional[types.sensorsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single sensors record.

        Parameters
        ----------
        data
            sensors record data specifying what to update
        where
            sensors filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned sensors model

        Returns
        -------
        prisma.models.sensors
            The updated sensors record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        sensors = await sensors.prisma().update(
            where={
                'id': 1468890740,
            },
            data={
                # data to update the sensors record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.sensorsWhereUniqueInput,
        data: types.sensorsUpsertInput,
        include: Optional[types.sensorsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            sensors filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned sensors model

        Returns
        -------
        prisma.models.sensors
            The created or updated sensors record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        sensors = await sensors.prisma().upsert(
            where={
                'id': 629039005,
            },
            data={
                'create': {
                    'id': 629039005,
                    'idDistr': 1369828971,
                    'idSensor': 1678593480,
                    'value': 'eadfcbbcb',
                },
                'update': {
                    'idDistr': 1369828971,
                    'idSensor': 1678593480,
                    'value': 'eadfcbbcb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.sensorsUpdateManyMutationInput,
        where: types.sensorsWhereInput,
    ) -> int:
        """Update multiple sensors records

        Parameters
        ----------
        data
            sensors data to update the selected sensors records to
        where
            Filter to select the sensors records to update

        Returns
        -------
        int
            The total number of sensors records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all sensors records
        total = await sensors.prisma().update_many(
            data={
                'date': 'bcbebgiaic'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.sensorsWhereInput] = None,
        cursor: Optional[types.sensorsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of sensors records present in the database

        Parameters
        ----------
        select
            Select the sensors fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            sensors filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.sensorsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await sensors.prisma().count()

        # results: prisma.types.sensorsCountAggregateOutput
        results = await sensors.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.sensorsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.sensorsWhereInput] = None,
        cursor: Optional[types.sensorsWhereUniqueInput] = None,
    ) -> types.sensorsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.sensorsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.sensorsWhereInput] = None,
        cursor: Optional[types.sensorsWhereUniqueInput] = None,
    ) -> Union[int, types.sensorsCountAggregateOutput]:
        """Count the number of sensors records present in the database

        Parameters
        ----------
        select
            Select the sensors fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            sensors filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.sensorsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await sensors.prisma().count()

        # results: prisma.types.sensorsCountAggregateOutput
        results = await sensors.prisma().count(
            select={
                '_all': True,
                'idDistr': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.sensorsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.sensorsWhereInput] = None
    ) -> int:
        """Delete multiple sensors records.

        Parameters
        ----------
        where
            Optional sensors filter to find the records to be deleted

        Returns
        -------
        int
            The total number of sensors records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all sensors records
        total = await sensors.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.sensorsScalarFieldKeys'],
        *,
        where: Optional['types.sensorsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.sensorsAvgAggregateInput'] = None,
        sum: Optional['types.sensorsSumAggregateInput'] = None,
        min: Optional['types.sensorsMinAggregateInput'] = None,
        max: Optional['types.sensorsMaxAggregateInput'] = None,
        having: Optional['types.sensorsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.sensorsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.sensorsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.sensorsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.sensorsGroupByOutput']:
        """Group sensors records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar sensors fields to group records by
        where
            sensors filter to select records
        take
            Limit the maximum number of sensors records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.sensorsGroupByOutput]
            A list of dictionaries representing the sensors record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group sensors records by idSensor values
        # and count how many records are in each group
        results = await sensors.prisma().group_by(
            ['idSensor'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class taskActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.task]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await task.prisma().query_raw(
            'SELECT * FROM task WHERE id = ?',
            898613219,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.task
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await task.prisma().query_first(
            'SELECT * FROM task WHERE idDistr = ?',
            658378208,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.taskCreateInput,
        include: Optional[types.taskInclude] = None
    ) -> _PrismaModelT:
        """Create a new task record.

        Parameters
        ----------
        data
            task record data
        include
            Specifies which relations should be loaded on the returned task model

        Returns
        -------
        prisma.models.task
            The created task record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a task record from just the required fields
        task = await task.prisma().create(
            data={
                # data to create a task record
                'idDistr': 954620057,
                'idEntre': 1214809950,
                'idType': 1047820095,
                'date': 'bdachdeiga',
                'time': 'ijdafccef',
                'message': 'ciaaiddag',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.taskCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple task records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of task record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await task.prisma().create_many(
            data=[
                {
                    # data to create a task record
                    'idDistr': 549668955,
                    'idEntre': 76790008,
                    'idType': 2098299345,
                    'date': 'cefjaadec',
                    'time': 'ibbigdigd',
                    'message': 'bdiiiabbii',
                },
                {
                    # data to create a task record
                    'idDistr': 752577037,
                    'idEntre': 1187663298,
                    'idType': 769681363,
                    'date': 'bcbecjfice',
                    'time': 'bacbebhjjd',
                    'message': 'dfbfaddhe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.taskWhereUniqueInput,
        include: Optional[types.taskInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single task record.

        Parameters
        ----------
        where
            task filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned task model

        Returns
        -------
        prisma.models.task
            The deleted task record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        task = await task.prisma().delete(
            where={
                'id': 1321184815,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.taskWhereUniqueInput,
        include: Optional[types.taskInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique task record.

        Parameters
        ----------
        where
            task filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned task model

        Returns
        -------
        prisma.models.task
            The found task record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        task = await task.prisma().find_unique(
            where={
                'id': 369732668,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.taskWhereInput] = None,
        cursor: Optional[types.taskWhereUniqueInput] = None,
        include: Optional[types.taskInclude] = None,
        order: Optional[Union[types.taskOrderByInput, List[types.taskOrderByInput]]] = None,
        distinct: Optional[List[types.taskScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple task records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of task records returned
        skip
            Ignore the first N results
        where
            task filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned task model
        order
            Order the returned task records by any field
        distinct
            Filter task records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.task]
            The list of all task records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 task records
        tasks = await task.prisma().find_many(take=10)

        # find the first 5 task records ordered by the idUser field
        tasks = await task.prisma().find_many(
            take=5,
            order={
                'idUser': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.taskWhereInput] = None,
        cursor: Optional[types.taskWhereUniqueInput] = None,
        include: Optional[types.taskInclude] = None,
        order: Optional[Union[types.taskOrderByInput, List[types.taskOrderByInput]]] = None,
        distinct: Optional[List[types.taskScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single task record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            task filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned task model
        order
            Order the returned task records by any field
        distinct
            Filter task records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.task
            The first task record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second task record ordered by the idEntre field
        task = await task.prisma().find_first(
            skip=1,
            order={
                'idEntre': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.taskUpdateInput,
        where: types.taskWhereUniqueInput,
        include: Optional[types.taskInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single task record.

        Parameters
        ----------
        data
            task record data specifying what to update
        where
            task filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned task model

        Returns
        -------
        prisma.models.task
            The updated task record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        task = await task.prisma().update(
            where={
                'id': 1191235013,
            },
            data={
                # data to update the task record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.taskWhereUniqueInput,
        data: types.taskUpsertInput,
        include: Optional[types.taskInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            task filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned task model

        Returns
        -------
        prisma.models.task
            The created or updated task record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        task = await task.prisma().upsert(
            where={
                'id': 627561242,
            },
            data={
                'create': {
                    'id': 627561242,
                    'idDistr': 752577037,
                    'idEntre': 1187663298,
                    'idType': 769681363,
                    'date': 'bcbecjfice',
                    'time': 'bacbebhjjd',
                    'message': 'dfbfaddhe',
                },
                'update': {
                    'idDistr': 752577037,
                    'idEntre': 1187663298,
                    'idType': 769681363,
                    'date': 'bcbecjfice',
                    'time': 'bacbebhjjd',
                    'message': 'dfbfaddhe',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.taskUpdateManyMutationInput,
        where: types.taskWhereInput,
    ) -> int:
        """Update multiple task records

        Parameters
        ----------
        data
            task data to update the selected task records to
        where
            Filter to select the task records to update

        Returns
        -------
        int
            The total number of task records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all task records
        total = await task.prisma().update_many(
            data={
                'idType': 1872952907
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.taskWhereInput] = None,
        cursor: Optional[types.taskWhereUniqueInput] = None,
    ) -> int:
        """Count the number of task records present in the database

        Parameters
        ----------
        select
            Select the task fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            task filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.taskCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await task.prisma().count()

        # results: prisma.types.taskCountAggregateOutput
        results = await task.prisma().count(
            select={
                '_all': True,
                'isDone': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.taskCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.taskWhereInput] = None,
        cursor: Optional[types.taskWhereUniqueInput] = None,
    ) -> types.taskCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.taskCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.taskWhereInput] = None,
        cursor: Optional[types.taskWhereUniqueInput] = None,
    ) -> Union[int, types.taskCountAggregateOutput]:
        """Count the number of task records present in the database

        Parameters
        ----------
        select
            Select the task fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            task filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.taskCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await task.prisma().count()

        # results: prisma.types.taskCountAggregateOutput
        results = await task.prisma().count(
            select={
                '_all': True,
                'isOpen': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.taskCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.taskWhereInput] = None
    ) -> int:
        """Delete multiple task records.

        Parameters
        ----------
        where
            Optional task filter to find the records to be deleted

        Returns
        -------
        int
            The total number of task records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all task records
        total = await task.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.taskScalarFieldKeys'],
        *,
        where: Optional['types.taskWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.taskAvgAggregateInput'] = None,
        sum: Optional['types.taskSumAggregateInput'] = None,
        min: Optional['types.taskMinAggregateInput'] = None,
        max: Optional['types.taskMaxAggregateInput'] = None,
        having: Optional['types.taskScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.taskCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.taskScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.taskScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.taskGroupByOutput']:
        """Group task records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar task fields to group records by
        where
            task filter to select records
        take
            Limit the maximum number of task records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.taskGroupByOutput]
            A list of dictionaries representing the task record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group task records by date values
        # and count how many records are in each group
        results = await task.prisma().group_by(
            ['date'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class tokensActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.tokens]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await tokens.prisma().query_raw(
            'SELECT * FROM tokens WHERE id = ?',
            1793282088,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.tokens
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await tokens.prisma().query_first(
            'SELECT * FROM tokens WHERE idUser = ?',
            1814397249,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.tokensCreateInput,
        include: Optional[types.tokensInclude] = None
    ) -> _PrismaModelT:
        """Create a new tokens record.

        Parameters
        ----------
        data
            tokens record data
        include
            Specifies which relations should be loaded on the returned tokens model

        Returns
        -------
        prisma.models.tokens
            The created tokens record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a tokens record from just the required fields
        tokens = await tokens.prisma().create(
            data={
                # data to create a tokens record
                'idUser': 1923090150,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.tokensCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple tokens records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of tokens record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await tokens.prisma().create_many(
            data=[
                {
                    # data to create a tokens record
                    'idUser': 1277244455,
                },
                {
                    # data to create a tokens record
                    'idUser': 1160857300,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.tokensWhereUniqueInput,
        include: Optional[types.tokensInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single tokens record.

        Parameters
        ----------
        where
            tokens filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned tokens model

        Returns
        -------
        prisma.models.tokens
            The deleted tokens record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tokens = await tokens.prisma().delete(
            where={
                'id': 361230461,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.tokensWhereUniqueInput,
        include: Optional[types.tokensInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique tokens record.

        Parameters
        ----------
        where
            tokens filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned tokens model

        Returns
        -------
        prisma.models.tokens
            The found tokens record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tokens = await tokens.prisma().find_unique(
            where={
                'id': 1406511986,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.tokensWhereInput] = None,
        cursor: Optional[types.tokensWhereUniqueInput] = None,
        include: Optional[types.tokensInclude] = None,
        order: Optional[Union[types.tokensOrderByInput, List[types.tokensOrderByInput]]] = None,
        distinct: Optional[List[types.tokensScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple tokens records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of tokens records returned
        skip
            Ignore the first N results
        where
            tokens filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned tokens model
        order
            Order the returned tokens records by any field
        distinct
            Filter tokens records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.tokens]
            The list of all tokens records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 tokens records
        tokens = await tokens.prisma().find_many(take=10)

        # find the first 5 tokens records ordered by the token field
        tokens = await tokens.prisma().find_many(
            take=5,
            order={
                'token': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.tokensWhereInput] = None,
        cursor: Optional[types.tokensWhereUniqueInput] = None,
        include: Optional[types.tokensInclude] = None,
        order: Optional[Union[types.tokensOrderByInput, List[types.tokensOrderByInput]]] = None,
        distinct: Optional[List[types.tokensScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single tokens record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            tokens filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned tokens model
        order
            Order the returned tokens records by any field
        distinct
            Filter tokens records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.tokens
            The first tokens record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second tokens record ordered by the id field
        tokens = await tokens.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.tokensUpdateInput,
        where: types.tokensWhereUniqueInput,
        include: Optional[types.tokensInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single tokens record.

        Parameters
        ----------
        data
            tokens record data specifying what to update
        where
            tokens filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned tokens model

        Returns
        -------
        prisma.models.tokens
            The updated tokens record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        tokens = await tokens.prisma().update(
            where={
                'id': 1482877891,
            },
            data={
                # data to update the tokens record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.tokensWhereUniqueInput,
        data: types.tokensUpsertInput,
        include: Optional[types.tokensInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            tokens filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned tokens model

        Returns
        -------
        prisma.models.tokens
            The created or updated tokens record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tokens = await tokens.prisma().upsert(
            where={
                'id': 566623296,
            },
            data={
                'create': {
                    'id': 566623296,
                    'idUser': 1160857300,
                },
                'update': {
                    'idUser': 1160857300,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.tokensUpdateManyMutationInput,
        where: types.tokensWhereInput,
    ) -> int:
        """Update multiple tokens records

        Parameters
        ----------
        data
            tokens data to update the selected tokens records to
        where
            Filter to select the tokens records to update

        Returns
        -------
        int
            The total number of tokens records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all tokens records
        total = await tokens.prisma().update_many(
            data={
                'idUser': 229119865
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.tokensWhereInput] = None,
        cursor: Optional[types.tokensWhereUniqueInput] = None,
    ) -> int:
        """Count the number of tokens records present in the database

        Parameters
        ----------
        select
            Select the tokens fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            tokens filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.tokensCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await tokens.prisma().count()

        # results: prisma.types.tokensCountAggregateOutput
        results = await tokens.prisma().count(
            select={
                '_all': True,
                'token': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.tokensCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.tokensWhereInput] = None,
        cursor: Optional[types.tokensWhereUniqueInput] = None,
    ) -> types.tokensCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.tokensCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.tokensWhereInput] = None,
        cursor: Optional[types.tokensWhereUniqueInput] = None,
    ) -> Union[int, types.tokensCountAggregateOutput]:
        """Count the number of tokens records present in the database

        Parameters
        ----------
        select
            Select the tokens fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            tokens filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.tokensCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await tokens.prisma().count()

        # results: prisma.types.tokensCountAggregateOutput
        results = await tokens.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.tokensCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.tokensWhereInput] = None
    ) -> int:
        """Delete multiple tokens records.

        Parameters
        ----------
        where
            Optional tokens filter to find the records to be deleted

        Returns
        -------
        int
            The total number of tokens records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all tokens records
        total = await tokens.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.tokensScalarFieldKeys'],
        *,
        where: Optional['types.tokensWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.tokensAvgAggregateInput'] = None,
        sum: Optional['types.tokensSumAggregateInput'] = None,
        min: Optional['types.tokensMinAggregateInput'] = None,
        max: Optional['types.tokensMaxAggregateInput'] = None,
        having: Optional['types.tokensScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.tokensCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.tokensScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.tokensScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.tokensGroupByOutput']:
        """Group tokens records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar tokens fields to group records by
        where
            tokens filter to select records
        take
            Limit the maximum number of tokens records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.tokensGroupByOutput]
            A list of dictionaries representing the tokens record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group tokens records by idUser values
        # and count how many records are in each group
        results = await tokens.prisma().group_by(
            ['idUser'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class typetaskActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.typetask]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await typetask.prisma().query_raw(
            'SELECT * FROM typetask WHERE id = ?',
            1750011070,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.typetask
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await typetask.prisma().query_first(
            'SELECT * FROM typetask WHERE identifiant = ?',
            'ebajedhhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.typetaskCreateInput,
        include: Optional[types.typetaskInclude] = None
    ) -> _PrismaModelT:
        """Create a new typetask record.

        Parameters
        ----------
        data
            typetask record data
        include
            Specifies which relations should be loaded on the returned typetask model

        Returns
        -------
        prisma.models.typetask
            The created typetask record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a typetask record from just the required fields
        typetask = await typetask.prisma().create(
            data={
                # data to create a typetask record
                'identifiant': 'jajacedge',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.typetaskCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple typetask records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of typetask record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await typetask.prisma().create_many(
            data=[
                {
                    # data to create a typetask record
                    'identifiant': 'hffgbabgf',
                },
                {
                    # data to create a typetask record
                    'identifiant': 'biacbiieja',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.typetaskWhereUniqueInput,
        include: Optional[types.typetaskInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single typetask record.

        Parameters
        ----------
        where
            typetask filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned typetask model

        Returns
        -------
        prisma.models.typetask
            The deleted typetask record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        typetask = await typetask.prisma().delete(
            where={
                'id': 294916155,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.typetaskWhereUniqueInput,
        include: Optional[types.typetaskInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique typetask record.

        Parameters
        ----------
        where
            typetask filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned typetask model

        Returns
        -------
        prisma.models.typetask
            The found typetask record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        typetask = await typetask.prisma().find_unique(
            where={
                'id': 564073304,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.typetaskWhereInput] = None,
        cursor: Optional[types.typetaskWhereUniqueInput] = None,
        include: Optional[types.typetaskInclude] = None,
        order: Optional[Union[types.typetaskOrderByInput, List[types.typetaskOrderByInput]]] = None,
        distinct: Optional[List[types.typetaskScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple typetask records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of typetask records returned
        skip
            Ignore the first N results
        where
            typetask filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned typetask model
        order
            Order the returned typetask records by any field
        distinct
            Filter typetask records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.typetask]
            The list of all typetask records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 typetask records
        typetasks = await typetask.prisma().find_many(take=10)

        # find the first 5 typetask records ordered by the description field
        typetasks = await typetask.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.typetaskWhereInput] = None,
        cursor: Optional[types.typetaskWhereUniqueInput] = None,
        include: Optional[types.typetaskInclude] = None,
        order: Optional[Union[types.typetaskOrderByInput, List[types.typetaskOrderByInput]]] = None,
        distinct: Optional[List[types.typetaskScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single typetask record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            typetask filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned typetask model
        order
            Order the returned typetask records by any field
        distinct
            Filter typetask records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.typetask
            The first typetask record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second typetask record ordered by the id field
        typetask = await typetask.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.typetaskUpdateInput,
        where: types.typetaskWhereUniqueInput,
        include: Optional[types.typetaskInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single typetask record.

        Parameters
        ----------
        data
            typetask record data specifying what to update
        where
            typetask filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned typetask model

        Returns
        -------
        prisma.models.typetask
            The updated typetask record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        typetask = await typetask.prisma().update(
            where={
                'id': 380648625,
            },
            data={
                # data to update the typetask record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.typetaskWhereUniqueInput,
        data: types.typetaskUpsertInput,
        include: Optional[types.typetaskInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            typetask filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned typetask model

        Returns
        -------
        prisma.models.typetask
            The created or updated typetask record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        typetask = await typetask.prisma().upsert(
            where={
                'id': 1030616470,
            },
            data={
                'create': {
                    'id': 1030616470,
                    'identifiant': 'biacbiieja',
                },
                'update': {
                    'identifiant': 'biacbiieja',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.typetaskUpdateManyMutationInput,
        where: types.typetaskWhereInput,
    ) -> int:
        """Update multiple typetask records

        Parameters
        ----------
        data
            typetask data to update the selected typetask records to
        where
            Filter to select the typetask records to update

        Returns
        -------
        int
            The total number of typetask records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all typetask records
        total = await typetask.prisma().update_many(
            data={
                'identifiant': 'ibgebbjch'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.typetaskWhereInput] = None,
        cursor: Optional[types.typetaskWhereUniqueInput] = None,
    ) -> int:
        """Count the number of typetask records present in the database

        Parameters
        ----------
        select
            Select the typetask fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            typetask filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.typetaskCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await typetask.prisma().count()

        # results: prisma.types.typetaskCountAggregateOutput
        results = await typetask.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.typetaskCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.typetaskWhereInput] = None,
        cursor: Optional[types.typetaskWhereUniqueInput] = None,
    ) -> types.typetaskCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.typetaskCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.typetaskWhereInput] = None,
        cursor: Optional[types.typetaskWhereUniqueInput] = None,
    ) -> Union[int, types.typetaskCountAggregateOutput]:
        """Count the number of typetask records present in the database

        Parameters
        ----------
        select
            Select the typetask fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            typetask filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.typetaskCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await typetask.prisma().count()

        # results: prisma.types.typetaskCountAggregateOutput
        results = await typetask.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.typetaskCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.typetaskWhereInput] = None
    ) -> int:
        """Delete multiple typetask records.

        Parameters
        ----------
        where
            Optional typetask filter to find the records to be deleted

        Returns
        -------
        int
            The total number of typetask records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all typetask records
        total = await typetask.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.typetaskScalarFieldKeys'],
        *,
        where: Optional['types.typetaskWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.typetaskAvgAggregateInput'] = None,
        sum: Optional['types.typetaskSumAggregateInput'] = None,
        min: Optional['types.typetaskMinAggregateInput'] = None,
        max: Optional['types.typetaskMaxAggregateInput'] = None,
        having: Optional['types.typetaskScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.typetaskCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.typetaskScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.typetaskScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.typetaskGroupByOutput']:
        """Group typetask records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar typetask fields to group records by
        where
            typetask filter to select records
        take
            Limit the maximum number of typetask records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.typetaskGroupByOutput]
            A list of dictionaries representing the typetask record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group typetask records by identifiant values
        # and count how many records are in each group
        results = await typetask.prisma().group_by(
            ['identifiant'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class usersActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.users]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await users.prisma().query_raw(
            'SELECT * FROM users WHERE id = ?',
            1084099844,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.users
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await users.prisma().query_first(
            'SELECT * FROM users WHERE nom = ?',
            'bahjhaccfd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.usersCreateInput,
        include: Optional[types.usersInclude] = None
    ) -> _PrismaModelT:
        """Create a new users record.

        Parameters
        ----------
        data
            users record data
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The created users record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a users record from just the required fields
        users = await users.prisma().create(
            data={
                # data to create a users record
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.usersCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple users records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of users record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await users.prisma().create_many(
            data=[
                {
                    # data to create a users record
                },
                {
                    # data to create a users record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.usersWhereUniqueInput,
        include: Optional[types.usersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single users record.

        Parameters
        ----------
        where
            users filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The deleted users record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await users.prisma().delete(
            where={
                'id': 755750178,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.usersWhereUniqueInput,
        include: Optional[types.usersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique users record.

        Parameters
        ----------
        where
            users filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The found users record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await users.prisma().find_unique(
            where={
                'id': 1128680371,
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
        include: Optional[types.usersInclude] = None,
        order: Optional[Union[types.usersOrderByInput, List[types.usersOrderByInput]]] = None,
        distinct: Optional[List[types.usersScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple users records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of users records returned
        skip
            Ignore the first N results
        where
            users filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users model
        order
            Order the returned users records by any field
        distinct
            Filter users records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.users]
            The list of all users records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 users records
        users = await users.prisma().find_many(take=10)

        # find the first 5 users records ordered by the prenom field
        users = await users.prisma().find_many(
            take=5,
            order={
                'prenom': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
        include: Optional[types.usersInclude] = None,
        order: Optional[Union[types.usersOrderByInput, List[types.usersOrderByInput]]] = None,
        distinct: Optional[List[types.usersScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single users record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            users filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users model
        order
            Order the returned users records by any field
        distinct
            Filter users records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.users
            The first users record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second users record ordered by the mail field
        users = await users.prisma().find_first(
            skip=1,
            order={
                'mail': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.usersUpdateInput,
        where: types.usersWhereUniqueInput,
        include: Optional[types.usersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single users record.

        Parameters
        ----------
        data
            users record data specifying what to update
        where
            users filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The updated users record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await users.prisma().update(
            where={
                'id': 259061104,
            },
            data={
                # data to update the users record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.usersWhereUniqueInput,
        data: types.usersUpsertInput,
        include: Optional[types.usersInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            users filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The created or updated users record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await users.prisma().upsert(
            where={
                'id': 1115738345,
            },
            data={
                'create': {
                    'id': 1115738345,
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.usersUpdateManyMutationInput,
        where: types.usersWhereInput,
    ) -> int:
        """Update multiple users records

        Parameters
        ----------
        data
            users data to update the selected users records to
        where
            Filter to select the users records to update

        Returns
        -------
        int
            The total number of users records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all users records
        total = await users.prisma().update_many(
            data={
                'mdp': 'bdadhibhec'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
    ) -> int:
        """Count the number of users records present in the database

        Parameters
        ----------
        select
            Select the users fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            users filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.usersCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await users.prisma().count()

        # results: prisma.types.usersCountAggregateOutput
        results = await users.prisma().count(
            select={
                '_all': True,
                'tel': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.usersCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
    ) -> types.usersCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.usersCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
    ) -> Union[int, types.usersCountAggregateOutput]:
        """Count the number of users records present in the database

        Parameters
        ----------
        select
            Select the users fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            users filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.usersCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await users.prisma().count()

        # results: prisma.types.usersCountAggregateOutput
        results = await users.prisma().count(
            select={
                '_all': True,
                'idRole': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.usersCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.usersWhereInput] = None
    ) -> int:
        """Delete multiple users records.

        Parameters
        ----------
        where
            Optional users filter to find the records to be deleted

        Returns
        -------
        int
            The total number of users records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all users records
        total = await users.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.usersScalarFieldKeys'],
        *,
        where: Optional['types.usersWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.usersAvgAggregateInput'] = None,
        sum: Optional['types.usersSumAggregateInput'] = None,
        min: Optional['types.usersMinAggregateInput'] = None,
        max: Optional['types.usersMaxAggregateInput'] = None,
        having: Optional['types.usersScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.usersCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.usersScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.usersScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.usersGroupByOutput']:
        """Group users records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar users fields to group records by
        where
            users filter to select records
        take
            Limit the maximum number of users records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.usersGroupByOutput]
            A list of dictionaries representing the users record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group users records by idCreatedpar values
        # and count how many records are in each group
        results = await users.prisma().group_by(
            ['idCreatedpar'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            operation='query',
            method='groupBy',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models
