# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseConfig, BaseModel, Field, validator

from . import types, enums, errors, fields, bases
from ._types import FuncType
from .builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class annonceur(bases.Baseannonceur):
    """Represents a annonceur record"""

    id: _int
    nom: Optional[_str]
    prenom: Optional[_str]
    mail: Optional[_str]
    tel: Optional[_str]
    idCreatedpar: Optional[_int]

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.annonceurKeys']] = None,
        exclude: Optional[Iterable['types.annonceurKeys']] = None,
        required: Optional[Iterable['types.annonceurKeys']] = None,
        optional: Optional[Iterable['types.annonceurKeys']] = None,
        relations: Optional[Mapping['types.annonceurRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.annonceurKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _annonceur_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _annonceur_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _annonceur_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _annonceur_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "annonceur" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid annonceur / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'annonceur',
            }
        )
        _created_partial_types.add(name)


class categorie(bases.Basecategorie):
    """Represents a categorie record"""

    id: _int
    categorie: Optional[_str]

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.categorieKeys']] = None,
        exclude: Optional[Iterable['types.categorieKeys']] = None,
        required: Optional[Iterable['types.categorieKeys']] = None,
        optional: Optional[Iterable['types.categorieKeys']] = None,
        relations: Optional[Mapping['types.categorieRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.categorieKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _categorie_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _categorie_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _categorie_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _categorie_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "categorie" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid categorie / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'categorie',
            }
        )
        _created_partial_types.add(name)


class categoryclaims(bases.Basecategoryclaims):
    """Represents a categoryclaims record"""

    id: _int
    claim: Optional[_str]
    message: _str
    reclamation: Optional[List['models.reclamation']]

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.categoryclaimsKeys']] = None,
        exclude: Optional[Iterable['types.categoryclaimsKeys']] = None,
        required: Optional[Iterable['types.categoryclaimsKeys']] = None,
        optional: Optional[Iterable['types.categoryclaimsKeys']] = None,
        relations: Optional[Mapping['types.categoryclaimsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.categoryclaimsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _categoryclaims_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _categoryclaims_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _categoryclaims_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _categoryclaims_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _categoryclaims_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _categoryclaims_relational_fields:
                        raise errors.UnknownRelationalFieldError('categoryclaims', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid categoryclaims / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'categoryclaims',
            }
        )
        _created_partial_types.add(name)


class categoryrecette(bases.Basecategoryrecette):
    """Represents a categoryrecette record"""

    id: _int
    description: Optional[_str]
    publicite: Optional[List['models.publicite']]
    recette: Optional[List['models.recette']]

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.categoryrecetteKeys']] = None,
        exclude: Optional[Iterable['types.categoryrecetteKeys']] = None,
        required: Optional[Iterable['types.categoryrecetteKeys']] = None,
        optional: Optional[Iterable['types.categoryrecetteKeys']] = None,
        relations: Optional[Mapping['types.categoryrecetteRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.categoryrecetteKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _categoryrecette_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _categoryrecette_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _categoryrecette_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _categoryrecette_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _categoryrecette_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _categoryrecette_relational_fields:
                        raise errors.UnknownRelationalFieldError('categoryrecette', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid categoryrecette / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'categoryrecette',
            }
        )
        _created_partial_types.add(name)


class categorysensors(bases.Basecategorysensors):
    """Represents a categorysensors record"""

    id: _int
    sensor: Optional[_str]
    security: _bool
    sensors: Optional[List['models.sensors']]

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.categorysensorsKeys']] = None,
        exclude: Optional[Iterable['types.categorysensorsKeys']] = None,
        required: Optional[Iterable['types.categorysensorsKeys']] = None,
        optional: Optional[Iterable['types.categorysensorsKeys']] = None,
        relations: Optional[Mapping['types.categorysensorsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.categorysensorsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _categorysensors_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _categorysensors_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _categorysensors_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _categorysensors_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _categorysensors_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _categorysensors_relational_fields:
                        raise errors.UnknownRelationalFieldError('categorysensors', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid categorysensors / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'categorysensors',
            }
        )
        _created_partial_types.add(name)


class commande(bases.Basecommande):
    """Represents a commande record"""

    id: _int
    idRecette: _int
    idIngredient: Optional[_int]
    quantity: _str
    ingredient: Optional['models.ingredient']
    recette: Optional['models.recette']
    facture: Optional[List['models.facture']]

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.commandeKeys']] = None,
        exclude: Optional[Iterable['types.commandeKeys']] = None,
        required: Optional[Iterable['types.commandeKeys']] = None,
        optional: Optional[Iterable['types.commandeKeys']] = None,
        relations: Optional[Mapping['types.commandeRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.commandeKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _commande_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _commande_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _commande_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _commande_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _commande_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _commande_relational_fields:
                        raise errors.UnknownRelationalFieldError('commande', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid commande / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'commande',
            }
        )
        _created_partial_types.add(name)


class distributeur(bases.Basedistributeur):
    """Represents a distributeur record"""

    id: _int
    identifiant: _str
    capaciteGoblet: Optional[_int]
    capaciteSucre: Optional[_int]
    capaciteSpoon: Optional[_int]
    distributeurRecette: Optional[List['models.distributeurRecette']]
    facture: Optional[List['models.facture']]
    pack: Optional['models.pack']
    sensors: Optional[List['models.sensors']]

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.distributeurKeys']] = None,
        exclude: Optional[Iterable['types.distributeurKeys']] = None,
        required: Optional[Iterable['types.distributeurKeys']] = None,
        optional: Optional[Iterable['types.distributeurKeys']] = None,
        relations: Optional[Mapping['types.distributeurRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.distributeurKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _distributeur_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _distributeur_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _distributeur_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _distributeur_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _distributeur_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _distributeur_relational_fields:
                        raise errors.UnknownRelationalFieldError('distributeur', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid distributeur / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'distributeur',
            }
        )
        _created_partial_types.add(name)


class distributeurRecette(bases.BasedistributeurRecette):
    """Represents a distributeurRecette record"""

    idDistr: _int
    idRecette: _int
    price: decimal.Decimal
    distributeur: Optional['models.distributeur']
    recette: Optional['models.recette']

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.distributeurRecetteKeys']] = None,
        exclude: Optional[Iterable['types.distributeurRecetteKeys']] = None,
        required: Optional[Iterable['types.distributeurRecetteKeys']] = None,
        optional: Optional[Iterable['types.distributeurRecetteKeys']] = None,
        relations: Optional[Mapping['types.distributeurRecetteRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.distributeurRecetteKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _distributeurRecette_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _distributeurRecette_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _distributeurRecette_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _distributeurRecette_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _distributeurRecette_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _distributeurRecette_relational_fields:
                        raise errors.UnknownRelationalFieldError('distributeurRecette', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid distributeurRecette / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'distributeurRecette',
            }
        )
        _created_partial_types.add(name)


class entrepise(bases.Baseentrepise):
    """Represents a entrepise record"""

    id: _int
    nom: Optional[_str]
    adresse: Optional[_str]
    mail: Optional[_str]
    tel: Optional[_str]
    link: Optional[_str]
    pack: Optional[List['models.pack']]
    task: Optional[List['models.task']]
    users: Optional[List['models.users']]

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.entrepiseKeys']] = None,
        exclude: Optional[Iterable['types.entrepiseKeys']] = None,
        required: Optional[Iterable['types.entrepiseKeys']] = None,
        optional: Optional[Iterable['types.entrepiseKeys']] = None,
        relations: Optional[Mapping['types.entrepiseRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.entrepiseKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _entrepise_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _entrepise_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _entrepise_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _entrepise_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _entrepise_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _entrepise_relational_fields:
                        raise errors.UnknownRelationalFieldError('entrepise', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid entrepise / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'entrepise',
            }
        )
        _created_partial_types.add(name)


class facture(bases.Basefacture):
    """Represents a facture record"""

    id: _int
    idDistr: Optional[_int]
    idComm: Optional[_int]
    idInfoPaiment: Optional[_int]
    commande: Optional['models.commande']
    distributeur: Optional['models.distributeur']
    infopaiment: Optional['models.infopaiment']

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.factureKeys']] = None,
        exclude: Optional[Iterable['types.factureKeys']] = None,
        required: Optional[Iterable['types.factureKeys']] = None,
        optional: Optional[Iterable['types.factureKeys']] = None,
        relations: Optional[Mapping['types.factureRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.factureKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _facture_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _facture_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _facture_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _facture_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _facture_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _facture_relational_fields:
                        raise errors.UnknownRelationalFieldError('facture', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid facture / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'facture',
            }
        )
        _created_partial_types.add(name)


class infopaiment(bases.Baseinfopaiment):
    """Represents a infopaiment record"""

    id: _int
    mail: Optional[_str]
    cartePaiment: Optional[_str]
    ccv: Optional[_str]
    expiryDate: Optional[_str]
    facture: Optional[List['models.facture']]

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.infopaimentKeys']] = None,
        exclude: Optional[Iterable['types.infopaimentKeys']] = None,
        required: Optional[Iterable['types.infopaimentKeys']] = None,
        optional: Optional[Iterable['types.infopaimentKeys']] = None,
        relations: Optional[Mapping['types.infopaimentRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.infopaimentKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _infopaiment_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _infopaiment_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _infopaiment_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _infopaiment_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _infopaiment_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _infopaiment_relational_fields:
                        raise errors.UnknownRelationalFieldError('infopaiment', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid infopaiment / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'infopaiment',
            }
        )
        _created_partial_types.add(name)


class ingredient(bases.Baseingredient):
    """Represents a ingredient record"""

    id: _int
    type: Optional[_int]
    description: Optional[_str]
    prixUnit: Optional[_int]
    commande: Optional[List['models.commande']]
    recetteingr: Optional[List['models.recetteingr']]

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ingredientKeys']] = None,
        exclude: Optional[Iterable['types.ingredientKeys']] = None,
        required: Optional[Iterable['types.ingredientKeys']] = None,
        optional: Optional[Iterable['types.ingredientKeys']] = None,
        relations: Optional[Mapping['types.ingredientRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ingredientKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ingredient_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ingredient_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ingredient_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ingredient_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ingredient_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ingredient_relational_fields:
                        raise errors.UnknownRelationalFieldError('ingredient', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ingredient / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ingredient',
            }
        )
        _created_partial_types.add(name)


class pack(bases.Basepack):
    """Represents a pack record"""

    idDistr: _int
    idEntre: _int
    codeverou: Optional[_str]
    localisation: Optional[_str]
    state: Optional[_str]
    distributeur: Optional['models.distributeur']
    entrepise: Optional['models.entrepise']

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.packKeys']] = None,
        exclude: Optional[Iterable['types.packKeys']] = None,
        required: Optional[Iterable['types.packKeys']] = None,
        optional: Optional[Iterable['types.packKeys']] = None,
        relations: Optional[Mapping['types.packRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.packKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _pack_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _pack_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _pack_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _pack_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _pack_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _pack_relational_fields:
                        raise errors.UnknownRelationalFieldError('pack', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid pack / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'pack',
            }
        )
        _created_partial_types.add(name)


class publicite(bases.Basepublicite):
    """Represents a publicite record"""

    id: _int
    url: Optional[_str]
    idCategorie: Optional[_int]
    idCategRecette: Optional[_int]
    idAnnonceur: Optional[_int]
    categoryrecette: Optional['models.categoryrecette']

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.publiciteKeys']] = None,
        exclude: Optional[Iterable['types.publiciteKeys']] = None,
        required: Optional[Iterable['types.publiciteKeys']] = None,
        optional: Optional[Iterable['types.publiciteKeys']] = None,
        relations: Optional[Mapping['types.publiciteRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.publiciteKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _publicite_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _publicite_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _publicite_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _publicite_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _publicite_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _publicite_relational_fields:
                        raise errors.UnknownRelationalFieldError('publicite', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid publicite / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'publicite',
            }
        )
        _created_partial_types.add(name)


class recette(bases.Baserecette):
    """Represents a recette record"""

    id: _int
    idCategRecette: Optional[_int]
    name: Optional[_str]
    description: Optional[_str]
    price: decimal.Decimal
    imageLink: Optional[_str]
    commande: Optional[List['models.commande']]
    distributeurRecette: Optional[List['models.distributeurRecette']]
    categoryrecette: Optional['models.categoryrecette']
    recetteingr: Optional[List['models.recetteingr']]

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.recetteKeys']] = None,
        exclude: Optional[Iterable['types.recetteKeys']] = None,
        required: Optional[Iterable['types.recetteKeys']] = None,
        optional: Optional[Iterable['types.recetteKeys']] = None,
        relations: Optional[Mapping['types.recetteRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.recetteKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _recette_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _recette_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _recette_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _recette_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _recette_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _recette_relational_fields:
                        raise errors.UnknownRelationalFieldError('recette', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid recette / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'recette',
            }
        )
        _created_partial_types.add(name)


class recetteingr(bases.Baserecetteingr):
    """Represents a recetteingr record"""

    idRecette: _int
    idIngredient: _int
    quantity: Optional[_str]
    ingredient: Optional['models.ingredient']
    recette: Optional['models.recette']

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.recetteingrKeys']] = None,
        exclude: Optional[Iterable['types.recetteingrKeys']] = None,
        required: Optional[Iterable['types.recetteingrKeys']] = None,
        optional: Optional[Iterable['types.recetteingrKeys']] = None,
        relations: Optional[Mapping['types.recetteingrRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.recetteingrKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _recetteingr_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _recetteingr_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _recetteingr_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _recetteingr_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _recetteingr_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _recetteingr_relational_fields:
                        raise errors.UnknownRelationalFieldError('recetteingr', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid recetteingr / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'recetteingr',
            }
        )
        _created_partial_types.add(name)


class reclamation(bases.Basereclamation):
    """Represents a reclamation record"""

    id: _int
    idFacture: Optional[_int]
    message: Optional[_str]
    isDone: Optional[_bool]
    idCategoryClaim: Optional[_int]
    categoryclaims: Optional['models.categoryclaims']

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.reclamationKeys']] = None,
        exclude: Optional[Iterable['types.reclamationKeys']] = None,
        required: Optional[Iterable['types.reclamationKeys']] = None,
        optional: Optional[Iterable['types.reclamationKeys']] = None,
        relations: Optional[Mapping['types.reclamationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.reclamationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _reclamation_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _reclamation_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _reclamation_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _reclamation_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _reclamation_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _reclamation_relational_fields:
                        raise errors.UnknownRelationalFieldError('reclamation', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid reclamation / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'reclamation',
            }
        )
        _created_partial_types.add(name)


class role(bases.Baserole):
    """Represents a role record"""

    id: _int
    description: Optional[_str]

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.roleKeys']] = None,
        exclude: Optional[Iterable['types.roleKeys']] = None,
        required: Optional[Iterable['types.roleKeys']] = None,
        optional: Optional[Iterable['types.roleKeys']] = None,
        relations: Optional[Mapping['types.roleRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.roleKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _role_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _role_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _role_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _role_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "role" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid role / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'role',
            }
        )
        _created_partial_types.add(name)


class sensors(bases.Basesensors):
    """Represents a sensors record"""

    id: _int
    idDistr: _int
    idSensor: _int
    value: _str
    date: Optional[_str]
    distributeur: Optional['models.distributeur']
    categorysensors: Optional['models.categorysensors']

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.sensorsKeys']] = None,
        exclude: Optional[Iterable['types.sensorsKeys']] = None,
        required: Optional[Iterable['types.sensorsKeys']] = None,
        optional: Optional[Iterable['types.sensorsKeys']] = None,
        relations: Optional[Mapping['types.sensorsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.sensorsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _sensors_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _sensors_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _sensors_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _sensors_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _sensors_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _sensors_relational_fields:
                        raise errors.UnknownRelationalFieldError('sensors', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid sensors / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'sensors',
            }
        )
        _created_partial_types.add(name)


class task(bases.Basetask):
    """Represents a task record"""

    id: _int
    idDistr: _int
    idUser: Optional[_int]
    idEntre: _int
    idType: _int
    isDone: _bool
    isOpen: _bool
    date: _str
    time: _str
    message: _str
    entrepise: Optional['models.entrepise']
    typetask: Optional['models.typetask']
    users: Optional['models.users']

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.taskKeys']] = None,
        exclude: Optional[Iterable['types.taskKeys']] = None,
        required: Optional[Iterable['types.taskKeys']] = None,
        optional: Optional[Iterable['types.taskKeys']] = None,
        relations: Optional[Mapping['types.taskRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.taskKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _task_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _task_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _task_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _task_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _task_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _task_relational_fields:
                        raise errors.UnknownRelationalFieldError('task', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid task / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'task',
            }
        )
        _created_partial_types.add(name)


class tokens(bases.Basetokens):
    """Represents a tokens record"""

    id: _int
    idUser: _int
    token: Optional[_str]
    users: Optional['models.users']

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.tokensKeys']] = None,
        exclude: Optional[Iterable['types.tokensKeys']] = None,
        required: Optional[Iterable['types.tokensKeys']] = None,
        optional: Optional[Iterable['types.tokensKeys']] = None,
        relations: Optional[Mapping['types.tokensRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.tokensKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _tokens_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _tokens_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _tokens_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _tokens_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _tokens_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _tokens_relational_fields:
                        raise errors.UnknownRelationalFieldError('tokens', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid tokens / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'tokens',
            }
        )
        _created_partial_types.add(name)


class typetask(bases.Basetypetask):
    """Represents a typetask record"""

    id: _int
    identifiant: _str
    description: Optional[_str]
    task: Optional[List['models.task']]

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.typetaskKeys']] = None,
        exclude: Optional[Iterable['types.typetaskKeys']] = None,
        required: Optional[Iterable['types.typetaskKeys']] = None,
        optional: Optional[Iterable['types.typetaskKeys']] = None,
        relations: Optional[Mapping['types.typetaskRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.typetaskKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _typetask_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _typetask_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _typetask_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _typetask_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _typetask_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _typetask_relational_fields:
                        raise errors.UnknownRelationalFieldError('typetask', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid typetask / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'typetask',
            }
        )
        _created_partial_types.add(name)


class users(bases.Baseusers):
    """Represents a users record"""

    id: _int
    nom: Optional[_str]
    prenom: Optional[_str]
    mail: Optional[_str]
    mdp: Optional[_str]
    tel: Optional[_str]
    idRole: Optional[_int]
    idCreatedpar: Optional[_int]
    idEntreprise: Optional[_int]
    isActive: Optional[_int]
    task: Optional[List['models.task']]
    tokens: Optional['models.tokens']
    entrepise: Optional['models.entrepise']

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.usersKeys']] = None,
        exclude: Optional[Iterable['types.usersKeys']] = None,
        required: Optional[Iterable['types.usersKeys']] = None,
        optional: Optional[Iterable['types.usersKeys']] = None,
        relations: Optional[Mapping['types.usersRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.usersKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _users_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _users_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _users_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _users_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _users_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _users_relational_fields:
                        raise errors.UnknownRelationalFieldError('users', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid users / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'users',
            }
        )
        _created_partial_types.add(name)



_annonceur_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_annonceur_fields: Dict['types.annonceurKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('nom', {
            'name': 'nom',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('prenom', {
            'name': 'prenom',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('mail', {
            'name': 'mail',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tel', {
            'name': 'tel',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('idCreatedpar', {
            'name': 'idCreatedpar',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_categorie_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_categorie_fields: Dict['types.categorieKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('categorie', {
            'name': 'categorie',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_categoryclaims_relational_fields: Set[str] = {
        'reclamation',
    }
_categoryclaims_fields: Dict['types.categoryclaimsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('claim', {
            'name': 'claim',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('message', {
            'name': 'message',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('reclamation', {
            'name': 'reclamation',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.reclamation\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_categoryrecette_relational_fields: Set[str] = {
        'publicite',
        'recette',
    }
_categoryrecette_fields: Dict['types.categoryrecetteKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('publicite', {
            'name': 'publicite',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.publicite\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('recette', {
            'name': 'recette',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.recette\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_categorysensors_relational_fields: Set[str] = {
        'sensors',
    }
_categorysensors_fields: Dict['types.categorysensorsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('sensor', {
            'name': 'sensor',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('security', {
            'name': 'security',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('sensors', {
            'name': 'sensors',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.sensors\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_commande_relational_fields: Set[str] = {
        'ingredient',
        'recette',
        'facture',
    }
_commande_fields: Dict['types.commandeKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idRecette', {
            'name': 'idRecette',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idIngredient', {
            'name': 'idIngredient',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('quantity', {
            'name': 'quantity',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('ingredient', {
            'name': 'ingredient',
            'is_list': False,
            'optional': True,
            'type': 'models.ingredient',
            'is_relational': True,
            'documentation': None,
        }),
        ('recette', {
            'name': 'recette',
            'is_list': False,
            'optional': True,
            'type': 'models.recette',
            'is_relational': True,
            'documentation': None,
        }),
        ('facture', {
            'name': 'facture',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.facture\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_distributeur_relational_fields: Set[str] = {
        'distributeurRecette',
        'facture',
        'pack',
        'sensors',
    }
_distributeur_fields: Dict['types.distributeurKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('identifiant', {
            'name': 'identifiant',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('capaciteGoblet', {
            'name': 'capaciteGoblet',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('capaciteSucre', {
            'name': 'capaciteSucre',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('capaciteSpoon', {
            'name': 'capaciteSpoon',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('distributeurRecette', {
            'name': 'distributeurRecette',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.distributeurRecette\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('facture', {
            'name': 'facture',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.facture\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('pack', {
            'name': 'pack',
            'is_list': False,
            'optional': True,
            'type': 'models.pack',
            'is_relational': True,
            'documentation': None,
        }),
        ('sensors', {
            'name': 'sensors',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.sensors\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_distributeurRecette_relational_fields: Set[str] = {
        'distributeur',
        'recette',
    }
_distributeurRecette_fields: Dict['types.distributeurRecetteKeys', PartialModelField] = OrderedDict(
    [
        ('idDistr', {
            'name': 'idDistr',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idRecette', {
            'name': 'idRecette',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('price', {
            'name': 'price',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('distributeur', {
            'name': 'distributeur',
            'is_list': False,
            'optional': True,
            'type': 'models.distributeur',
            'is_relational': True,
            'documentation': None,
        }),
        ('recette', {
            'name': 'recette',
            'is_list': False,
            'optional': True,
            'type': 'models.recette',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_entrepise_relational_fields: Set[str] = {
        'pack',
        'task',
        'users',
    }
_entrepise_fields: Dict['types.entrepiseKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('nom', {
            'name': 'nom',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('adresse', {
            'name': 'adresse',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('mail', {
            'name': 'mail',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tel', {
            'name': 'tel',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('link', {
            'name': 'link',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pack', {
            'name': 'pack',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.pack\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('task', {
            'name': 'task',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.task\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('users', {
            'name': 'users',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.users\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_facture_relational_fields: Set[str] = {
        'commande',
        'distributeur',
        'infopaiment',
    }
_facture_fields: Dict['types.factureKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idDistr', {
            'name': 'idDistr',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idComm', {
            'name': 'idComm',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idInfoPaiment', {
            'name': 'idInfoPaiment',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('commande', {
            'name': 'commande',
            'is_list': False,
            'optional': True,
            'type': 'models.commande',
            'is_relational': True,
            'documentation': None,
        }),
        ('distributeur', {
            'name': 'distributeur',
            'is_list': False,
            'optional': True,
            'type': 'models.distributeur',
            'is_relational': True,
            'documentation': None,
        }),
        ('infopaiment', {
            'name': 'infopaiment',
            'is_list': False,
            'optional': True,
            'type': 'models.infopaiment',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_infopaiment_relational_fields: Set[str] = {
        'facture',
    }
_infopaiment_fields: Dict['types.infopaimentKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('mail', {
            'name': 'mail',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('cartePaiment', {
            'name': 'cartePaiment',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('ccv', {
            'name': 'ccv',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('expiryDate', {
            'name': 'expiryDate',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('facture', {
            'name': 'facture',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.facture\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ingredient_relational_fields: Set[str] = {
        'commande',
        'recetteingr',
    }
_ingredient_fields: Dict['types.ingredientKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('prixUnit', {
            'name': 'prixUnit',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('commande', {
            'name': 'commande',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.commande\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('recetteingr', {
            'name': 'recetteingr',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.recetteingr\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_pack_relational_fields: Set[str] = {
        'distributeur',
        'entrepise',
    }
_pack_fields: Dict['types.packKeys', PartialModelField] = OrderedDict(
    [
        ('idDistr', {
            'name': 'idDistr',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idEntre', {
            'name': 'idEntre',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('codeverou', {
            'name': 'codeverou',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('localisation', {
            'name': 'localisation',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('state', {
            'name': 'state',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('distributeur', {
            'name': 'distributeur',
            'is_list': False,
            'optional': True,
            'type': 'models.distributeur',
            'is_relational': True,
            'documentation': None,
        }),
        ('entrepise', {
            'name': 'entrepise',
            'is_list': False,
            'optional': True,
            'type': 'models.entrepise',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_publicite_relational_fields: Set[str] = {
        'categoryrecette',
    }
_publicite_fields: Dict['types.publiciteKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('url', {
            'name': 'url',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('idCategorie', {
            'name': 'idCategorie',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idCategRecette', {
            'name': 'idCategRecette',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idAnnonceur', {
            'name': 'idAnnonceur',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('categoryrecette', {
            'name': 'categoryrecette',
            'is_list': False,
            'optional': True,
            'type': 'models.categoryrecette',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_recette_relational_fields: Set[str] = {
        'commande',
        'distributeurRecette',
        'categoryrecette',
        'recetteingr',
    }
_recette_fields: Dict['types.recetteKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idCategRecette', {
            'name': 'idCategRecette',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('price', {
            'name': 'price',
            'is_list': False,
            'optional': False,
            'type': 'decimal.Decimal',
            'is_relational': False,
            'documentation': None,
        }),
        ('imageLink', {
            'name': 'imageLink',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('commande', {
            'name': 'commande',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.commande\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('distributeurRecette', {
            'name': 'distributeurRecette',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.distributeurRecette\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('categoryrecette', {
            'name': 'categoryrecette',
            'is_list': False,
            'optional': True,
            'type': 'models.categoryrecette',
            'is_relational': True,
            'documentation': None,
        }),
        ('recetteingr', {
            'name': 'recetteingr',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.recetteingr\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_recetteingr_relational_fields: Set[str] = {
        'ingredient',
        'recette',
    }
_recetteingr_fields: Dict['types.recetteingrKeys', PartialModelField] = OrderedDict(
    [
        ('idRecette', {
            'name': 'idRecette',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idIngredient', {
            'name': 'idIngredient',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('quantity', {
            'name': 'quantity',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('ingredient', {
            'name': 'ingredient',
            'is_list': False,
            'optional': True,
            'type': 'models.ingredient',
            'is_relational': True,
            'documentation': None,
        }),
        ('recette', {
            'name': 'recette',
            'is_list': False,
            'optional': True,
            'type': 'models.recette',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_reclamation_relational_fields: Set[str] = {
        'categoryclaims',
    }
_reclamation_fields: Dict['types.reclamationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idFacture', {
            'name': 'idFacture',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('message', {
            'name': 'message',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isDone', {
            'name': 'isDone',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('idCategoryClaim', {
            'name': 'idCategoryClaim',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('categoryclaims', {
            'name': 'categoryclaims',
            'is_list': False,
            'optional': True,
            'type': 'models.categoryclaims',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_role_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_role_fields: Dict['types.roleKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_sensors_relational_fields: Set[str] = {
        'distributeur',
        'categorysensors',
    }
_sensors_fields: Dict['types.sensorsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idDistr', {
            'name': 'idDistr',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idSensor', {
            'name': 'idSensor',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('value', {
            'name': 'value',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('date', {
            'name': 'date',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('distributeur', {
            'name': 'distributeur',
            'is_list': False,
            'optional': True,
            'type': 'models.distributeur',
            'is_relational': True,
            'documentation': None,
        }),
        ('categorysensors', {
            'name': 'categorysensors',
            'is_list': False,
            'optional': True,
            'type': 'models.categorysensors',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_task_relational_fields: Set[str] = {
        'entrepise',
        'typetask',
        'users',
    }
_task_fields: Dict['types.taskKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idDistr', {
            'name': 'idDistr',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idUser', {
            'name': 'idUser',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idEntre', {
            'name': 'idEntre',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idType', {
            'name': 'idType',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('isDone', {
            'name': 'isDone',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('isOpen', {
            'name': 'isOpen',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('date', {
            'name': 'date',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('time', {
            'name': 'time',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('message', {
            'name': 'message',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('entrepise', {
            'name': 'entrepise',
            'is_list': False,
            'optional': True,
            'type': 'models.entrepise',
            'is_relational': True,
            'documentation': None,
        }),
        ('typetask', {
            'name': 'typetask',
            'is_list': False,
            'optional': True,
            'type': 'models.typetask',
            'is_relational': True,
            'documentation': None,
        }),
        ('users', {
            'name': 'users',
            'is_list': False,
            'optional': True,
            'type': 'models.users',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_tokens_relational_fields: Set[str] = {
        'users',
    }
_tokens_fields: Dict['types.tokensKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idUser', {
            'name': 'idUser',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('token', {
            'name': 'token',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('users', {
            'name': 'users',
            'is_list': False,
            'optional': True,
            'type': 'models.users',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_typetask_relational_fields: Set[str] = {
        'task',
    }
_typetask_fields: Dict['types.typetaskKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('identifiant', {
            'name': 'identifiant',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('task', {
            'name': 'task',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.task\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_users_relational_fields: Set[str] = {
        'task',
        'tokens',
        'entrepise',
    }
_users_fields: Dict['types.usersKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('nom', {
            'name': 'nom',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('prenom', {
            'name': 'prenom',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('mail', {
            'name': 'mail',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('mdp', {
            'name': 'mdp',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tel', {
            'name': 'tel',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('idRole', {
            'name': 'idRole',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idCreatedpar', {
            'name': 'idCreatedpar',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idEntreprise', {
            'name': 'idEntreprise',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('task', {
            'name': 'task',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.task\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('tokens', {
            'name': 'tokens',
            'is_list': False,
            'optional': True,
            'type': 'models.tokens',
            'is_relational': True,
            'documentation': None,
        }),
        ('entrepise', {
            'name': 'entrepise',
            'is_list': False,
            'optional': True,
            'type': 'models.entrepise',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
annonceur.update_forward_refs()
categorie.update_forward_refs()
categoryclaims.update_forward_refs()
categoryrecette.update_forward_refs()
categorysensors.update_forward_refs()
commande.update_forward_refs()
distributeur.update_forward_refs()
distributeurRecette.update_forward_refs()
entrepise.update_forward_refs()
facture.update_forward_refs()
infopaiment.update_forward_refs()
ingredient.update_forward_refs()
pack.update_forward_refs()
publicite.update_forward_refs()
recette.update_forward_refs()
recetteingr.update_forward_refs()
reclamation.update_forward_refs()
role.update_forward_refs()
sensors.update_forward_refs()
task.update_forward_refs()
tokens.update_forward_refs()
typetask.update_forward_refs()
users.update_forward_refs()
